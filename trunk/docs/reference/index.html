<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>BeanIO 2.0 Reference Guide</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="shortcut icon" href="http://www.beanio.org/favicon.ico" />
</head>
<body>

<div class="title">BeanIO 2.0 Reference Guide</div>
<p><i>Revision 1</i>, &copy; 2010-2012 Kevin Seim</p>
<p style="font-size: 90%"><i>Copies of this document may be made for your own use and for
distribution to others, provided that you do not charge any fee for such copies and further provided
that each copy contains this Copyright Notice, whether distributed in print or electronically.</i></p>
<p style="font-size: 100%;"></p>
<h1>Table of Contents</h1>
<div class="toc">
<a href="#Introduction">1.0. Introduction</a><br />
<div class="toc">
  <a href="#WhatsNew">1.1. What's new in 2.0?</a><br />
 <a href="#Migration">1.2. Migrating From 1.2.x</a><br />
</div>
<a href="#GettingStarted">2.0. Getting Started</a><br />
<div class="toc"><a href="#MyFirstStream">2.1. My First Stream</a></div>
<a href="#CoreConcepts">3.0. Core Concepts</a><br />
<div class="toc">
  <a href="#BeanReader">3.1. BeanReader</a><br />
  <a href="#BeanWriter">3.2. BeanWriter</a><br />
  <a href="#Unmarshaller">3.3. Unmarshaller</a><br />
  <a href="#Marshaller">3.4. Marshaller</a><br />
  <a href="#MappingFiles">3.5. Mapping Files</a><br />
  <a href="#StreamFactory">3.6. StreamFactory</a><br />
  <a href="#ExceptionHandling">3.7. Exception Handling</a><br />
  <div class="toc">
  	<a href="#BeanReaderErrorHandler">3.7.1. BeanReaderErrorHandler</a><br />
  </div>
</div>
<a href="#TheMappingFile">4.0. The Mapping File</a>
<div class="toc">
  <a href="#Streams">4.1. Streams</a><br />
  <div class="toc">
  	<a href="#CSVStreamFormat">4.1.1. CSV Streams</a><br />
  	<a href="#DelimitedStreamFormat">4.1.2. Delimited Streams</a><br />
  	<a href="#FixedLengthStreamFormat">4.1.3. Fixed Length Streams</a><br />
    <a href="#XmlStreamFormat">4.1.4. XML Streams</a><br />
  </div>
  <a href="#Records">4.2. Records</a><br />
  <div class="toc">
	<a href="#RecordIdentification">4.2.1. Record Identification</a><br />
	<a href="#RecordOrdering">4.2.2. Record Ordering</a><br />
	<a href="#RecordGrouping">4.2.3. Record Grouping</a><br />
  </div>
  <a href="#FieldDefinitions">4.3. Fields</a><br />
  <div class="toc">
	<a href="#FieldTypeConversion">4.3.1. Field Type Conversion</a><br />
	<a href="#CustomTypeHandlers">4.3.2. Custom Type Handlers</a><br />
	<a href="#RepeatingFields">4.3.3. Repeating Fields</a><br />
	<a href="#FixedLengthFields">4.3.4. Fixed Length Fields</a><br />
  </div>
  <a href="#Constants">4.4. Constants</a><br />
  <a href="#Segments">4.5. Segments</a><br />
  <div class="toc">
    <a href="#NestedBeans">4.5.1. Nested Beans</a><br />
	<a href="#RepeatingSegments">4.5.2. Repeating Segments</a><br />
  </div>
  <a href="#StreamValidation">4.6. Stream Validation</a><br />
  <div class="toc">
    <a href="#RecordValidation">4.6.1. Record Validation</a><br />
    <a href="#FieldValidation">4.6.2. Field Validation</a><br />
  </div>
  <a href="#Templates">4.7. Templates</a><br />
  <a href="#AdvancedTopics">4.8. Advanced Topics</a><br />
  <div class="toc">
    <a href="#RecordGroups">4.8.1.  Mapping Bean Objects that Span Multiple Records</a><br />
  </div>
</div>
<a href="#MappingXmlStreams">5.0.  Mapping XML Streams</a><br />
<div class="toc">
  <a href="#XmlIntroduction">5.1.  Introduction</a><br />
  <div class="toc">
    <a href="#MyFirstXmlStream">5.1.1.  My First XML Stream</a><br />
    <a href="#XmlValidation">5.1.2.  A Note on XML Validation</a><br />
  </div>
  <a href="#XmlNames">5.2.  XML Names</a><br />
  <a href="#XmlNamespaces">5.3.  XML Namespaces</a><br />
  <a href="#XmlStreams">5.4.  Streams</a><br />
  <a href="#XmlGroups">5.5.  Groups</a><br />
  <a href="#XmlRecords">5.6.  Records</a><br />
  <a href="#XmlFields">5.7.  Fields</a><br />
  <div class="toc">
    <a href="#XmlTypeConversion">5.7.1.  Field Type Conversion</a><br />
    <a href="#NullFields">5.7.2.  Marshalling Null Fields</a><br />
  </div>
  <a href="#XmlSegments">5.8.  Segments</a><br />
  <div class="toc">
    <a href="#XmlNestedBeans">5.8.1.  Nested Beans</a><br />
    <a href="#XmlWrappedSegments">5.8.2.  Wrapped Segments</a><br />
  </div>
</div>
<a href="#SpringBatch">6.0. Spring Batch Integration</a>
<div class="toc">
  <a href="#SpringItemReaderWriter">6.1. BeanIO ItemReader/Writer Beans</a><br />
  <a href="#SpringStreamFactory">6.2. BeanIO StreamFactory Bean</a>
</div>
<a href="#Configuration">7.0. Configuration</a>
<div class="toc">
  <a href="#ConfigurationSettings">7.1. Settings</a>
</div>
<a href="#A">Appendix A: XML Mapping File Reference</a><br />
<div class="toc">
  <a href="#beanio">A.1. <tt>beanio</tt></a><br />
  <a href="#import">A.2. <tt>import</tt></a><br />
  <a href="#typeHandler">A.3. <tt>typeHandler</tt></a><br />
  <a href="#property">A.4. <tt>property</tt></a><br />
  <a href="#template">A.5. <tt>template</tt></a><br />
  <a href="#include">A.6. <tt>include</tt></a><br />
  <a href="#stream">A.7. <tt>stream</tt></a><br />
  <a href="#parser">A.8. <tt>parser</tt></a><br />
  <a href="#group">A.9. <tt>group</tt></a><br />
  <a href="#record">A.10. <tt>record</tt></a><br />
  <a href="#segment">A.11. <tt>segment</tt></a><br />
  <a href="#field">A.12. <tt>field</tt></a><br />
</div>
<a href="#B">Appendix B: Error Message Parameters</a><br />
<a href="#C">Appendix C: Upgrading a 1.x Mapping File Example</a><br />
</div>

<h1><a name="Introduction">1.0. Introduction</a></h1>
<p>BeanIO is an open source Java framework for reading and writing Java beans or plain old java
objects (POJO's) from a flat file or stream.  BeanIO is ideally suited for batch processing, and
currently supports XML, CSV, delimited and fixed length file formats. BeanIO is licensed under the <a
  href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>.</p>

<h2><a name="WhatsNew">1.1. What's new in 2.0?</a></h2>
<p>BeanIO 2.0 includes an entirely new parsing engine that supports the following enhancements:</p>
<ul>
  <li>Support for mapping bean objects that span multiple records</li>
  <li>New <tt>Marshaller</tt> and <tt>Unmarshaller</tt> interfaces for marshalling and unmarshalling single records</li>
  <li>Support for constructor arguments and direct access to public attributes of a bean object</li>
  <li>The <tt>BeanWriter</tt> is now stateful for all stream formats (based on configured <tt>group</tt> and <tt>record</tt> occurrences)</li>
  <li>A more versatile <tt>segment</tt> mapping element replaces the <tt>bean</tt> element and <tt>xmlWrapper</tt> attribute</li>
  <li>OSGi support, including a user specified <tt>ClassLoader</tt> per <tt>StreamFactory</tt>.</li>
  <li>More lenient/sensible defaults.</li>
  <li>Consolidated <tt>reader</tt> and <tt>writer</tt> elements (see <a href="#parser"><tt>parser</tt></a>).</li>
  <li>Support for unmarshalling a subset of a record using a record <tt>target</tt> attribute</li>
</ul>

<h2><a name="Migration">1.2. Migrating from 1.2.x</a></h2>
<p>Release 2.0 is not backwards compatible with prior releases.  Sorry.  This section contains the
steps you'll need to follow to update your code and mapping files.</p>

<h3>1.2.1. Java Changes</h3>
<p>The <tt>org.beanio.BeanReaderContext</tt> class was renamed 
<a href="../api/org/beanio/RecordContext.html"><tt>org.beanio.RecordContext</tt></a> in order
to support bean objects bound to multiple records.</p>

<p>The exception classes <tt>org.beanio.BeanReaderException</tt> and <tt>org.beanio.BeanWriterException</tt>
are no longer abstract and may be thrown in a few rare (but fatal) scenarios.  The exception classes 
<tt>org.beanio.BeanReaderIOException</tt> and <tt>org.beanio.BeanWriterIOException</tt> are now only thrown
when the underlying input stream throws a <tt>java.io.IOException</tt>, or when a BeanReader/Writer method
is invoked on a closed stream.</p>

<p>The <tt>org.beanio.stream.RecordReaderFactory</tt> and <tt>org.beanio.stream.RecordWriterFactory</tt> interfaces
have been consolidated into the <a href="../api/org/beanio/stream/RecordParserFactory.html"><tt>RecordParserFactory</tt></a>
interface, which is also used to create <a href="../api/org/beanio/stream/RecordMarshaller.html"><tt>RecordMarshaller</tt></a>
and <a href="../api/org/beanio/stream/RecordUnmarshaller.html"><tt>RecordUnmarshaller</tt></a> implementations
for parsing individual records.</p>

<p>All type handlers and Spring related classes are unchanged or backwards compatible.
Internal implementation classes have been moved to the <tt>org.beanio.internal</tt> package and their API
may change in any release without further regard to backwards compatibility.</p>

<h3>1.2.2. Mapping File Changes</h3>
<p>The mapping file namespace has changed to <tt>http://www.beanio.org/2012/03</tt> for all elements.</p>

<p>Release 2.0 includes more lenient defaults for some mapping components.  A new <tt>stream</tt> attribute 
called <tt>strict</tt> has been added to support some legacy behavior.  If <tt>strict</tt> is set 
to true, the following behavior is enabled (which mimics prior releases):</p>
<ol>
<li>A default order is calculated for groups and records that do not have <tt>order</tt> explicitly set, based
  on the order they appear in the mapping file.</li>
<li>CSV, delimited and fixed length <tt>record</tt> elements will use default <tt>minLength</tt> and <tt>maxLength</tt> settings
  calculated based on it's children.  (If <tt>strict</tt> is false, release 2.0 defaults <tt>minLength</tt> to 0 and 
  <tt>maxLength</tt> to <tt>unbounded</tt>.)</li>
</ol>

<p>The <tt>ordered</tt> attribute has been removed from a <tt>stream</tt>.  Since release 2.0, all record and group 
components are unordered by default.  The <tt>order</tt> attribute is still supported.  
If you want to continue validating record order, you can set <tt>order</tt>
attributes on ordered groups and records, or set <tt>strict</tt> to true as described above to have BeanIO calculate
a default order.</p>

<p>The <tt>reader</tt> and <tt>writer</tt> elements have been combined into a single <tt>parser</tt> element.
Format specific property names have not changed.  If you have overridden the default <tt>RecordReaderFactory</tt> or
<tt>RecordWriterFactory</tt>, you will need to modify your class to implement 
<a href="../api/org/beanio/stream/RecordParserFactory.html"><tt>RecordParserFactory</tt></a> instead.
See section <b>TODO</b>.</p>

<p>The <tt>minOccurs</tt> attribute for a <tt>record</tt> now defaults to 0, instead of 1.</p>

<p>All <tt>bean</tt> elements should be renamed <tt>segment</tt>.  A <tt>segment</tt> element supports
all the functionality of a <tt>bean</tt> element (and more).</p>

<p>For XML formatted streams, the <tt>minOccurs</tt> attribute for a <tt>bean/segment</tt>, or a <tt>field</tt>
bound to an XML element, will always default to 1.  Prior to release 2.0, <tt>minOccurs</tt> 
defaulted to 0 if not nillable.  (This is now consistent with XML Schema and hopefully simpler to remember.)  The
default <tt>minOccurs</tt> attribute for a <tt>field</tt> bound to an XML attribute remains 0.</p>

<p>The <tt>xmlWrapper</tt> attribute has been removed.  XML wrappers can be replaced by <tt>segment</tt> components.</p>

<p>Mapping file changes are illustrated using an example in <a href="#C">Appendix C</a>.</p>


<h1><a name="GettingStarted">2.0. Getting Started</a></h1>
<p>To get started with BeanIO, download the latest stable version from 
<a href="http://code.google.com/p/beanio/">Google Code</a>, extract the contents of the ZIP file, 
and add <tt>beanio.jar</tt> to your application's classpath.</p>

<p>BeanIO requires a version 1.5 JDK or higher.  In order to process XML formatted streams,
BeanIO also requires an XML parser based on the Streaming API for XML (StAX), as specified by 
<a href="http://www.jcp.org/en/jsr/detail?id=173">JSR 173</a>.  JDK 1.6 and higher includes
a StAX implementation and therefore does not require any additional libraries.  JDK 1.5 users
will need to include the following:</p>
<ul>
<li>The StAX/JSR 173 API JAR, available from <a href="http://sjsxp.java.net/">Project SJSXP</a>.</li>
<li>A StAX implementation JAR.  A reference implementation, used for BeanIO development and included
in JDK 1.6, is available from <a href="http://sjsxp.java.net/">Project SJSXP</a>.</li>
</ul>

<p>Alternatively, <a href="http://maven.apache.org/">Maven</a> users can declare the following dependencies
  in their application's POM.  Note that the version numbers used below are only examples 
  and may have changed.</p>
<pre>
    &lt;!-- BeanIO dependency --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.beanio&lt;/groupId&gt;
      &lt;artifactId&gt;beanio&lt;/artifactId&gt;
      &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- StAX dependencies for JDK 1.5 users --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.xml&lt;/groupId&gt;
      &lt;artifactId&gt;jsr173&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.sun.xml.stream&lt;/groupId&gt;
      &lt;artifactId&gt;sjsxp&lt;/artifactId&gt;
      &lt;version&gt;1.0.2&lt;/version&gt;
    &lt;/dependency&gt;
</pre>

<h2><a name="MyFirstStream">2.1. My First Stream</a></h2>
<p>This section explores a simple example that uses BeanIO to read and write
a flat file containing employee data.  Let's suppose the file is in CSV format
and has the following record layout: </p>

<div class="indent">
  <table>
    <tr><th>Position</th><th>Field</th><th>Format</th></tr>
    <tr><td>0</td><td>First Name</td><td>Text</td></tr>
    <tr><td>1</td><td>Last Name</td><td>Text</td></tr>
    <tr><td>2</td><td>Job Title</td><td>Text</td></tr>
    <tr><td>3</td><td>Salary</td><td>Number</td></tr>
    <tr><td>4</td><td>Hire Date</td><td>Date (MMDDYYYY)</td></tr>
  </table>
</div>

<p>A sample file is shown below.</p>
<pre class="file">
Joe,Smith,Developer,75000,10012009
Jane,Doe,Architect,80000,01152008
Jon,Anderson,Manager,85000,03182007</pre>

<p>Next, let's suppose we want to read records into the following Java bean for further processing.
Remember that a Java bean must have a default no-argument constructor and public getters and setters
for all exposed properties.</p>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>BeanIO uses an XML configuration file, called a mapping file, to define how bean objects are bound
to records.  Below is a mapping file, named <tt>mapping.xml</tt>, that could be
used to read the sample employee file and unmarshall records into <tt>Employee</tt> objects.  The
same mapping file can be used to write, or marshall, <tt>Employee</tt> objects to a file
or output stream.</p>
<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2012/03" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd"&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
&lt;/beanio&gt;</pre>

<p>To read the employee CSV file, a <tt>StreamFactory</tt> is used to load our mapping
file and create a new <tt>BeanReader</tt> instance.  The <tt>BeanReader</tt> is used to unmarshall 
<tt>Employee</tt> objects from the file <tt>employee.csv</tt>.  (For the sake of brevity, proper exception handling 
is not shown.)</p>
<pre class="java">
package example;

import org.beanio.*;
import java.io.*;

public class BeanReaderExample {
    public static void main(String[] args) throws Exception {
        <span class="comment">// create a StreamFactory</span>
        StreamFactory factory = StreamFactory.newInstance();
        <span class="comment">// load the mapping file</span>
        factory.load("mapping.xml");
        
        <span class="comment">// use a StreamFactory to create a BeanReader</span>
        BeanReader in = factory.createReader("employeeFile", new File("employee.csv"));
        Employee employee;
        while ((employee = (Employee) in.read()) != null) {
            <span class="comment">// process the employee...</span>
        }
        in.close();
    }
}</pre>

<p>To write an employee CSV file, the same <tt>StreamFactory</tt> class
is used to create a <tt>BeanWriter</tt> for marshalling <tt>Employee</tt> bean objects to
the file <tt>employee.csv</tt>.  In this example, the same mapping configuration file is used for
both reading and writing an employee file.</p>
<pre class="java">
package example;

import org.beanio.*;
import java.io.*;
import java.util.*;

public class BeanWriterExample {
    public static void main(String[] args) throws Exception {
        <span class="comment">// create a StreamFactory</span>
        StreamFactory factory = StreamFactory.newInstance();
        <span class="comment">// load the mapping file</span>
        factory.load("mapping.xml");
        
        Employee employee = new Employee();
        employee.setFirstName("Jennifer");
        employee.setLastName("Jones");
        employee.setTitle("Marketing")
        employee.setSalary(60000);
        employee.setHireDate(new Date());
        
        <span class="comment">// use a StreamFactory to create a BeanWriter</span>
        BeanWriter out = factory.createWriter("employeeFile", new File("employee.csv"));
        <span class="comment">// write an Employee object directly to the BeanWriter</span>
        out.write(employee);
        out.flush();
        out.close();
    }
}</pre>

<p>Running <tt>BeanWriterExample</tt> produces the following CSV file.</p>
<pre class="file">
Jennifer,Jones,Marketing,60000,01012011</pre>

<h1><a name="CoreConcepts">3.0. Core Concepts</a></h1>

<h2><a name="BeanReader">3.1. BeanReader</a></h2>
<p>The <a href="../api/org/beanio/BeanReader.html"><tt>org.beanio.BeanReader</tt></a> interface, shown below, 
is used to read bean objects from
an input stream.  The <tt>read()</tt> method returns an unmarshalled bean object for the next record
or group of records read from the input stream.  When the end of the stream is reached, <tt>null</tt> 
is returned.</p>

<p>The method <tt>setErrorHandler(...)</tt> can be used to register a custom error
handler.  If an error handler is not configured, <tt>read()</tt> simply throws the 
unhandled exception.</p>

<p>The method <tt>getRecordName()</tt> returns the name of the record (or group) mapped to
the most recent bean object read from the input stream, as declared in the mapping file.  And  
<tt>getLineNumber()</tt> returns the line number of the first record mapped to the most recent
bean object read from the input stream.  Additional information is available about records read from the stream by calling
<tt>getRecordCount</tt> and <tt>getRecordContext</tt>.  Please consult the API documentation for further information.</p>

<p>Before discarding a <tt>BeanReader</tt>, <tt>close()</tt> should be invoked to close the underlying
input stream.</p>  
<pre class="file">
package org.beanio;

public interface BeanReader {

    public Object read() throws BeanReaderException;
    
    public int getLineNumber();
    
    public String getRecordName();
    
    public int getRecordCount();
    
    public RecordContext getRecordContext(int index); 
    
    public int skip(int count) throws BeanReaderException;
    
    public void close() throws BeanReaderIOException;
    
    public void setErrorHandler(BeanReaderErrorHandler errorHandler);
}</pre>

<h2><a name="BeanWriter">3.2. BeanWriter</a></h2>
<p>The <a href="../api/org/beanio/BeanWriter.html"><tt>org.beanio.BeanWriter</tt></a> interface, shown below, 
is used to write bean objects to an output stream.  Calling the <tt>write(Object)</tt> method marshals a bean 
object to the output stream.  In some cases where multiple record types are not discernible by class type 
or record identifying fields, the <tt>write(String,Object)</tt> method can be used to 
explicitly name the record type to marshal. </p>
<p>Before discarding a <tt>BeanWriter</tt>, <tt>close()</tt> should be invoked to close the underlying
output stream.</p>  
<pre class="file">
package org.beanio;

public interface BeanWriter {

    public void write(Object bean) throws BeanWriterException;
    
    public void write(String recordName, Object bean) throws BeanWriterException;
    
    public void flush() throws BeanWriterIOException;
    
    public void close() throws BeanWriterIOException;
}</pre>

<h2><a name="Unmarshaller">3.3. Unmarshaller</a></h2>
<p>The <a href="../api/org/beanio/Unmarshaller.html"><tt>org.beanio.Unmarshaller</tt></a> interface, shown below, 
is used to unmarshal a bean object from a <tt>String</tt> record.</p>
<pre class="file">
package org.beanio;

public interface Unmarshaller {

    <span class="comment">// For all stream formats</span>
    public Object unmarshal(String record) throws BeanReaderException;
    
    <span class="comment">// For CSV and delimited formatted streams</span>
    public Object unmarshal(List&lt;String&gt; fields) throws BeanReaderException;
    public Object unmarshal(String[] fields) throws BeanReaderException;

    <span class="comment">// For XML formatted streams</span>
    public Object unmarshal(Node node) throws BeanReaderException;
    
    public String getRecordName();
    
    public RecordContext getRecordContext();
}</pre>

<h2><a name="Marshaller">3.4. Marshaller</a></h2>
<p>The <a href="../api/org/beanio/Marshaller.html"><tt>org.beanio.Marshaller</tt></a> interface, shown below, 
is used to marshal a bean object into a <tt>String</tt> record.</p>
<pre class="file">
package org.beanio;

public interface Marshaller {

    public Marshaller marshal(Object bean) throws BeanWriterException;
    
    public Marshaller marshal(String recordName, Object bean) throws BeanWriterException;
    
    <span class="comment">// For all stream formats</span>
    public String toString();
    
    <span class="comment">// For CSV and delimited formatted streams</span>
    public String[] toArray() throws BeanWriterException;
    public List&lt;String&gt; toList() throws BeanWriterException;
    
    <span class="comment">// For XML formatted streams</span>
    public Document toDocument() throws BeanWriterException;
}</pre>

<p>Marshalling a single bean object to record text is now as simple as:</p>
<pre class="file">
String recordText = marshaller.marshal(object).toString();
</pre>

<h2><a name="MappingFiles">3.5. Mapping Files</a></h2>
<p>BeanIO uses XML configuration files, called mapping files,
to bind a stream layout to bean objects.  Multiple layouts
can be configured in a single mapping file using <tt>stream</tt> elements.  Each 
stream is assigned a unique name for referencing the layout.  In addition to
its name, every stream must declare its format using the <tt>format</tt> attribute.  
Supported stream formats include <tt>csv</tt>, <tt>delimited</tt>, <tt>fixedlength</tt>,
and <tt>xml</tt>.  Mapping files are fully explained in the next section 
(<a href="#TheMappingFile">4.0. The Mapping File</a>).</p>
<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2012/03" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd"&gt;

  &lt;stream name="stream1" format="csv"... &gt;
    &lt;!-- record layout... --&gt;
  &lt;/stream&gt;
  
  &lt;stream name="stream2" format="fixedlength"... &gt;
    &lt;!-- record layout... --&gt;
  &lt;/stream&gt;
    
&lt;/beanio&gt;</pre>

<h2><a name="StreamFactory">3.6. StreamFactory</a></h2>
<p>The <a href="../api/org/beanio/StreamFactory.html"><tt>org.beanio.StreamFactory</tt></a> class 
is used to load mapping files and create <tt>BeanReader</tt>, <tt>BeanWriter</tt>, <tt>Marshaller</tt> 
and <tt>Unmarshaller</tt> instances.  The following
code snippet shows how to instantiate a <tt>StreamFactory</tt>, load a mapping
file and create the various BeanIO parsers.  The <tt>load(...)</tt>
method loads mapping files from the file system (relative to the current working 
directory), while the method <tt>loadResource(...)</tt> loads mapping files from
the classpath.</p>

<pre class="java">
<span class="comment">// create a StreamFactory</span>
StreamFactory factory = StreamFactory.newInstance();
<span class="comment">// load 'mapping-1.xml' from the current working directory</span>
factory.load("mapping-1.xml");
<span class="comment">// load 'mapping-2.xml' from the classpath</span>
factory.loadResource("mapping-2.xml");'

<span class="comment">// create a BeanReader to read from 'in.txt'</span>
Reader in = new BufferedReader(new FileReader("in.txt"));
BeanReader beanReader = factory.createBeanReader("streamName", in);

<span class="comment">// create a BeanWriter to write to 'out.txt'</span>
Writer out = new BufferedWriter(new FileWriter("out.txt"));
BeanWriter beanWriter = factory.createBeanReader("streamName", out);

<span class="comment">// create an Unmarshaller to unmarshal bean objects from record text</span>
Unmarshaller unmarshaller = factory.createUnmarshaller("streamName");

<span class="comment">// create a Marshaller to marshal bean objects to record text</span>
Marshaller marshaller = factory.createMarshaller("streamName");
</pre>

<h2><a name="ExceptionHandling">3.7. Exception Handling</a></h2>
<p>All BeanIO exceptions extend from <tt>BeanIOException</tt>, which
extends from <tt>RuntimeException</tt> so that exceptions do not need
to be explicitly caught unless desired.  <tt>BeanReaderException</tt>
and <tt>BeanWriterException</tt> extend from <tt>BeanIOException</tt>
and may be thrown by a <tt>BeanReader</tt> or <tt>BeanWriter</tt>
respectively.  
</p>

<p>
A <tt>BeanReaderException</tt> is further broken down into
the following subclasses thrown by the <tt>read()</tt> method. 
</p>
<div class="indent">
<table>
<tr><th>Exception</th><th>Description</th></tr>

<tr>
  <td><tt>BeanReaderIOException</tt></td>
  <td>Thrown when the underlying input stream throws an <tt>IOException</tt>.</td>
</tr>
<tr>
  <td><tt>MalformedRecordException</tt></td>
  <td>Thrown when the underlying input stream is malformed based on the configured
    stream format, and therefore a record could not be accurately read from the
    stream.  In many cases, further reads from the input stream will be unsuccessful.
  </td>
</tr>
<tr>
  <td><tt>UnidentifiedRecordException</tt></td>
  <td>Thrown when a record does not match any record definition configured in the 
    mapping file.  If the stream layout does not strictly enforce record
    sequencing, further reads from the input stream are likely to be successful.
  </td>
</tr>
<tr>
  <td><tt>UnexpectedRecordException</tt></td>
  <td>Thrown when a record is read out of order.  Once record sequencing is violated,
    further reads from the input stream are likely to be unsuccessful.
  </td>
</tr>
<tr>
  <td><tt>InvalidRecordException</tt></td>
  <td>Thrown when a record is matched, but the record is invalid for one of the following
    reasons:
    <ul>
      <li>A record level validation failed</li>
      <li>One or more field level validations failed</li>
      <li>Field type conversion failed</li>
    </ul>
    This exception has no effect on the state of the <tt>BeanReader</tt> and further reads 
    from the input stream can be safely performed.
  </td>
</tr>
<tr>
  <td><tt>InvalidRecordGroupException</tt></td>
  <td>Extends from <tt>InvalidRecordException</tt> and is thrown when one or more records in a group 
    (that are mapped to a single bean object) are invalid.  This exception has no effect on the state of the <tt>BeanReader</tt> and further reads 
    from the input stream can be safely performed.
  </td>
</tr>
<tr>
  <td><tt>BeanReaderException</tt></td>
  <td>Thrown directly in a few rare unrecoverable scenarios.</td>
</tr>
</table>
</div>

<p>When a <tt>BeanReaderException</tt> is thrown, information about the failed record(s) can
be accessed by calling <tt>exception.getRecordContext()</tt> to obtain a <tt>org.beanio.RecordContext</tt>.  
Please refer to the API javadocs for more information.</p>

<pre class="java">
package org.beanio;

public interface RecordContext {
    public int getLineNumber();
    public String getRecordText();
    public String getRecordName();
    public boolean hasErrors();
    public boolean hasRecordErrors();
    public Collection&lt;String&gt; getRecordErrors();
    public String getFieldText(String fieldName);
    public String getFieldText(String fieldName, int index);
    public boolean hasFieldErrors();
    public Map&lt;String, Collection&lt;String&gt;&gt; getFieldErrors();
    public Collection&lt;String&gt; getFieldErrors(String fieldName);
}</pre>


<h3><a name="BeanReaderErrorHandler">3.7.1. BeanReaderErrorHandler</a></h3>
<p>If you need to handle an exception and continue processing, it may be simpler to register
a <tt>BeanReaderErrorHandler</tt> using the <tt>beanReader.setErrorHandler()</tt> method.  The
<tt>BeanReaderErrorHandler</tt> interface is shown below.  Any exception thrown by the error
handler will be rethrown by the <tt>BeanReader</tt>.</p>
<pre class="java">
package org.beanio;

public interface BeanReaderErrorHandler {
    public void handleError(BeanReaderException ex) throws Exception;
}</pre>

<p>The following example shows how invalid records could be written to a reject file by
registering an error handler extending <tt>BeanReaderErrorHandlerSupport</tt>,
a subclass of <tt>BeanReaderErrorHandler</tt>.  All other exceptions are left uncaught and
will bubble up to the calling method.</p>
<pre class="java">
    BeanReader input;
    BufferedWriter rejects;
    try {
        input.setErrorHandler(new BeanReaderErrorHandlerSupport() {
            public void invalidRecord(InvalidRecordException ex) throws Exception {
                <span class="comment">// if a bean object is mapped to a record group,
                // the exception may contain more than one record</span>
            	for (int i=0, j=ex.getRecordCount(); i&lt;j; i++) {
                    rejects.write(ex.getRecordContext(i).getRecordText());
                    rejects.newLine();
                }
            }
        });
        
        Object record = null;
        while ((record = input.read()) != null) {
            <span class="comment">// process a valid record</span>
        }
        
        rejects.flush();
    }
    finally {
        input.close();
        rejects.close();
    }
</pre>



<h1><a name="TheMappingFile">4.0. The Mapping File</a></h1>
<p>An XML mapping file is used to configure a stream layout.</p>

<h2><a name="Streams">4.1. Streams</a></h2>
<p>A typical mapping file contains one or more stream layouts.  A <tt>stream</tt>
must have a <tt>name</tt> and <tt>format</tt> attribute configured. The name of the 
stream is used to reference the layout when creating a parser using a <tt>StreamFactory</tt>.  
And the format instructs
BeanIO how to interpret the stream.  Supported formats include <tt>xml</tt>, <tt>csv</tt>, 
<tt>delimited</tt> and <tt>fixedlength</tt>.  
</p> 
<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2012/03" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd"&gt;

  &lt;stream name="stream1" format="csv"... &gt;
    &lt;!-- record layout... --&gt;
  &lt;/stream&gt;
  
  &lt;stream name="stream2" format="fixedlength"... &gt;
    &lt;!-- record layout... --&gt;
  &lt;/stream&gt;
    
&lt;/beanio&gt;</pre>

<p>BeanIO parses (and formats) a record from a stream or text using a record parser generated by
a <tt>RecordParserFactory</tt>.  BeanIO allows you to create and customize your own <tt>RecordParserFactory</tt>,
but in most cases you can simply configure BeanIO's default record parser factory using a stream's
<tt>parser</tt> element.  The <tt>parser</tt> element allows you to set format specific properties on a
<tt>RecordParserFactory</tt>.  For example, the following stream layout changes the delimiter to a pipe
for the delimited stream 's1':</p>

<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2012/03" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd"&gt;

  &lt;stream name="s1" format="delmiited"&gt;
    <span class="highlight">&lt;parser&gt;
      &lt;property name="delimiter" value="|" /&gt;
    &lt;/parser&gt;</span>
    &lt;!-- record layout... --&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>The next few sections list available parser properties for each stream format.</p>

<!--
<h3><a name="RecordReaderWriter">4.1.1. RecordReader and RecordWriter</a></h3>
<p>Internally, BeanIO uses a <tt>RecordReader</tt> to read records from an input stream,
and a <tt>RecordWriter</tt> to write records to an output stream.</p>

<p>The <tt>RecordReader</tt> interface is shown below.  A record reader is responsible
for dividing a stream into records.  The actual Java representation of a record is dependent
on the format of the stream.  Delimited record readers (including CSV) parse an input stream into 
<tt>String[]</tt> records, where each value in the array is a delimited field.  
Fixed length record readers simply parse an input stream into <tt>String</tt> records.</p>
<pre class="java">
package org.beanio.stream;

public interface RecordReader {
    public Object read() throws IOException, RecordIOException;
    public void close() throws IOException;
    public int getRecordLineNumber();
    public String getRecordText();
}
</pre>


<p>Similarly, the <tt>RecordWriter</tt> interface show below is used to write records to an 
output stream.  Once again, the Java representation of a record is dependent on the format
of the stream.  Delimited (and CSV) records use a <tt>String[]</tt>, and fixed length
records simply use a <tt>String</tt>.</p>
<pre class="java">
package org.beanio.stream;

public interface RecordWriterFactory {
    public RecordWriter createWriter(Writer out) throws IllegalArgumentException;
}
</pre>

<p>A new <tt>RecordReader</tt> is created for each <tt>BeanReader</tt> using the
<tt>RecordReaderFactory</tt> interface shown below.</p>
<pre class="java">
package org.beanio.stream;

public interface RecordReaderFactory {
    public RecordReader createReader(Reader in) throws IllegalArgumentException;
}
</pre>

<p>And likewise, a new <tt>RecordWriter</tt> is created for each <tt>BeanWriter</tt> using the
<tt>RecordWriterFactory</tt> interface shown below.</p>
<pre class="java">
package org.beanio.stream;

public interface RecordWriterFactory {
    public RecordWriter createWriter(Writer out) throws IllegalArgumentException;
}
</pre>

<p>BeanIO includes default record readers and writers for XML, CSV, delimited and fixed length 
stream formats.  Default reader and writer settings can be overridden for any stream in
the mapping file using a <tt>reader</tt> or <tt>writer</tt> element.  Or if necessary,
you can even replace the default record reader or writer by setting the <tt>class</tt> attribute
to the fully qualified class name of the record reader or writer factory to use.  (Note that
custom record reader/writer implementations will not be supported for XML formatted streams
due to the tight coupling with the parser, although it is not prevented.)</p>

<p>In the example mapping file below, the default record reader's delimiter is changed to an astericks,
while the record writer implementation is completely replaced using the factory class
<tt>example.MyRecordWriterFactory</tt>.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="delimited"&gt;
    <span class="highlight">&lt;reader&gt;
      &lt;property name="delimiter" value="*" /&gt;
    &lt;/reader&gt; </span>
    <span class="highlight">&lt;writer class="example.MyRecordWriterFactory" /&gt; </span>
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>
 -->

<h3><a name="CSVStreamFormat">4.1.1. CSV Streams</a></h3>
<p>CSV formatted streams are parsed according to 
<a href="http://www.ietf.org/rfc/rfc4180.txt">RFC 4180</a> with one exception:
multi-line records are disabled (but this can be overridden).</p>

<p>The following properties can be used to customize default CSV parsers:</p>
<table class="indent">
<tr>
  <th>Property Name</th>
  <th>Type</th>
  <th>Description</th>
  <th>Affects</th>
</tr>
<tr>
  <td><tt>delimiter</tt></td>
  <td>char</td>
  <td>The field delimiter.  Defaults to a comma.</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>quote</tt></td>
  <td>char</td>
  <td>The quotation mark character used to wrap fields containing a delimiter character, a
    quotation mark, or new lines.  Defaults to the double quotation mark, ".</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>escape</tt></td>
  <td>Character</td>
  <td>The character used to escape a quotation mark in a quoted field.  Defaults to the
    double quotation mark, ".</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>comments</tt></td>
  <td>String[]</td>
  <td>A comma separated list of values for identifying commented lines.  If a line read from an input
    stream begins with any of the configured values, the line is ignored.  A backslash may
    be used to escape a comma and itself.  All whitespace is preserved.
    <p>Enabling comments require the input reader passed to <tt>StreamFactory</tt> to support marking.
    Among others, Java's <tt>BufferedReader</tt> and <tt>StringReader</tt> support marking.</p></td>
  <td><tt>BeanReader</tt></td>
</tr>
<tr>
  <td><tt>multilineEnabled</tt></td>
  <td>boolean</td>
  <td>If set to <tt>true</tt>, quoted fields may contain new line characters.  Defaults to <tt>false</tt>.</td>
  <td><tt>BeanReader</tt></td>
</tr>
<tr>
  <td><tt>whitespaceAllowed</tt></td>
  <td>boolean</td>
  <td>If set to <tt>true</tt>, whitespace is ignored and allowed before and after 
  quoted values.  For example, the following is allowed:
  <pre>
    Jennifer, "Jones" ,24</pre>
  Defaults to <tt>false</tt>.
  </td>
  <td><tt>BeanReader, Unmarshaller</tt></td>
</tr>
<tr>
  <td><tt>unquotedQuotesAllowed</tt></td>
  <td>boolean</td>
  <td>If set to <tt>true</tt>, field text containing quotation marks do not need to 
    be quoted unless the field text starts with a quotation mark.  For example, the
    following is allowed:
    <pre>
    Jennifer,She said "OK"</pre>
    Defaults to <tt>false</tt>.
  </td>  
  <td><tt>BeanReader, Unmarshaller</tt></td>
</tr>
<tr>
  <td><tt>recordTerminator</tt></td>
  <td>String</td>
  <td>The character used to signify the end of a record.  By default, any new line character
    (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading
    an input stream, and <tt>System.getProperty("line.separator")</tt> is used when writing
    to a stream.</td>
  <td><tt>BeanWriter</tt></td>
</tr>
<tr>
  <td><tt>alwaysQuote</tt></td>
  <td>boolean</td>
  <td>If set to <tt>true</tt>, field text is always quoted.  By default, a field is only quoted
  if it contains a delimeter, a quotation mark or new line characters.
  </td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
</table>

<h3><a name="DelimitedStreamFormat">4.1.2.  Delimited Streams</a></h3>
<p>The default delimited parsers can be customized using the following properties:</p>
<table class="indent">
<tr>
  <th>Property Name</th>
  <th>Type</th>
  <th>Description</th>
  <th>Affects</th>
</tr>
<tr>
  <td><tt>delimiter</tt></td>
  <td>char</td>
  <td>The field delimiter.  Defaults to the tab character.</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>escape</tt></td>
  <td>Character</td>
  <td>The escape character allowed to escape a delimiter or itself.  By default, escaping
    is disabled.</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>lineContinuationCharacter</tt></td>
  <td>Character</td>
  <td>If this character is the last character before a new line or carriage return is read,
    the record will continue reading from the next line.  By default, line continuation
    is disabled.</td>
  <td><tt>BeanReader</tt></td>
</tr>
<tr>
  <td><tt>recordTerminator</tt></td>
  <td>Character</td>
  <td>The character used to signify the end of a record.  By default, any new line character
    (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading
    an input stream, and <tt>System.getProperty("line.separator")</tt> is used when writing
    to a stream.</td>
  <td><tt>BeanReader, BeanWriter</tt></td>
</tr>
<tr>
  <td><tt>comments</tt></td>
  <td>String[]</td>
  <td>A comma separated list of values for identifying commented lines.  If a line read from an input
    stream begins with any of the configured values, the line is ignored.  A backslash may
    be used to escape a comma and itself.  All whitespace is preserved.
    <p>Enabling comments require the input reader passed to <tt>StreamFactory</tt> to support marking.
    Among others, Java's <tt>BufferedReader</tt> and <tt>StringReader</tt> support marking.</p></td>
  <td><tt>BeanReader</tt></td>
</tr>
</table>


<h3><a name="FixedLengthStreamFormat">4.1.3. Fixed Length Streams</a></h3>
<p>The default fixed length parsers can be customized using the following properties:</p>
<table class="indent">
<tr>
  <th>Property Name</th>
  <th>Type</th>
  <th>Description</th>
  <th>Affects</th>
</tr>
<tr>
  <td><tt>lineContinuationCharacter</tt></td>
  <td>Character</td>
  <td>If this character is the last character before a new line or carriage return is read,
    the record will continue reading from the next line.  By default, line continuation
    is disabled.</td>
  <td><tt>BeanReader</tt></td>
</tr>
<tr>
  <td><tt>recordTerminator</tt></td>
  <td>Character</td>
  <td>The character used to signify the end of a record.  By default, any new line character
    (line feed (LF), carriage return (CR), or CRLF combination) is accepted when reading
    an input stream, and <tt>System.getProperty("line.separator")</tt> is used when writing
    to a stream.</td>
  <td><tt>BeanReader, BeanWriter</tt></td>
</tr>
<tr>
  <td><tt>comments</tt></td>
  <td>String[]</td>
  <td>A comma separated list of values for identifying commented lines.  If a line read from an input
    stream begins with any of the configured values, the line is ignored.  A backslash may
    be used to escape a comma and itself.  All whitespace is preserved.
    <p>Enabling comments require the input reader passed to <tt>StreamFactory</tt> to support marking.
    Among others, Java's <tt>BufferedReader</tt> and <tt>StringReader</tt> support marking.</p></td>
  <td><tt>BeanReader</tt></td>
</tr>
</table>

<h3><a name="XmlStreamFormat">4.1.4. XML Streams</a></h3>
<p>The default XML parsers can be customized using the following properties:</p>
<table class="indent">
<tr>
  <th>Property Name</th>
  <th>Type</th>
  <th>Description</th>
  <th>Affects</th>
</tr>
<tr>
  <td><tt>suppressHeader</tt></td>
  <td>boolean</td>
  <td>If set to <tt>true</tt>, the XML header is suppressed in the marshalled
  document.  Defaults to <tt>false</tt>.</td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
<tr>
  <td><tt>version</tt></td>
  <td>String</td>
  <td>The XML header version.  Defaults to <tt>1.0</tt>.</td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
<tr>
  <td><tt>encoding</tt></td>
  <td>String</td>
  <td>The XML header encoding.  Defaults to 
    <tt>utf-8</tt>.  Note that this setting has no bearing on the actual
    encoding of the output stream.  If set to "", an encoding attribute
    is not included in the header.</td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
<tr>
  <td><tt>namespaces</tt></td>
  <td>String</td>
  <td>A space delimited list of XML prefixes and namespaces to declare
    on the root element of a marshalled document.  The property value
    should be formatted as
    <pre class="indent">prefix1 namespace1 prefix2 namespace2...</pre></td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
<tr>
  <td><tt>indentation</tt></td>
  <td>Integer</td>
  <td>The number of spaces to indent each level of XML.  By default, indentation
    is disabled using a value of -1.</td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
<tr>
  <td><tt>lineSeparator</tt></td>
  <td>String</td>
  <td>The character(s) used to separate lines when indentation is enabled. 
    By default, <tt>System.getProperty("line.separator")</tt> is used.</td>
  <td><tt>BeanWriter, Marshaller</tt></td>
</tr>
</table>


<h2><a name="Records">4.2. Records</a></h2>
<p>Each record type read from an input stream or written to an output stream must be mapped 
using a <tt>record</tt> element.  A stream mapping must include at least one record.  
A record mapping is used to validate the record and bind field values to a bean object.  
A simple record configuration is shown below.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="stream1" format="csv"&gt;
    <span class="highlight">&lt;record name="record1" class="example.Record"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="age" /&gt;
    &lt;/record&gt;</span>
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>
<p>In this example, a CSV formatted stream is mapped to a single record composed of
three fields: first name, last name and age.  When a record is read from a stream using a <tt>BeanReader</tt>,
the class <tt>example.Record</tt> is instantiated and its <tt>firstName</tt>, <tt>lastName</tt>
and <tt>age</tt> attributes are set using standard Java bean
setter naming conventions (e.g. <tt>setFirstName(String)</tt>).</p>

<p>Similarly, when a <tt>example.Record</tt> bean object is written to an output stream using
a <tt>BeanWriter</tt>, its <tt>firstName</tt>, <tt>lastName</tt> and <tt>age</tt> attributes
are retrieved from the bean object using standard Java bean getter naming conventions (e.g. <tt>getFirstName()</tt>).</p>

<p>BeanIO also supports Map based records by setting a record's <tt>class</tt>
attribute to <tt>map</tt>, or to the fully qualified class name of any class assignable
to <tt>java.util.Map</tt>.  Note that if you plan to use Map based records,
field types may need be explicitly configured using the <tt>type</tt> attribute, or BeanIO
will assume the field is of type <tt>java.lang.String</tt>  The <tt>type</tt> attribute
is further explained in section <a href="#FieldTypeConversion.">4.6. Field Type Conversion</a>.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="stream1" format="csv"&gt;
    &lt;record name="record1" <span class="highlight">class="map"</span>&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="age" <span class="highlight">type="int"</span>/&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>


<h3><a name="RecordIdentification">4.2.1. Record Identification</a></h3>
<p>Oftentimes, a stream is made up of multiple record types.  A typical batch file
may include one header, one trailer, and zero to many detail records.  BeanIO
allows a record to be identified by one or more of its fields using expected
literal values or regular expressions.  If desired, BeanIO can be used to validate 
the order of all records in the input stream.</p>
<p>To see how a stream can be configured to handle multiple record types, let's
modify our Employee file to include a header and trailer record as shown below.  Each record 
now includes a record type field that identifies the type of record.</p>
<pre class="file">
Header,01012011
Detail,Joe,Smith,Developer,75000,10012009
Detail,Jane,Doe,Architect,80000,01152008
Detail,Jon,Anderson,Manager,85000,03182007
Trailer,3</pre>

<p>The mapping file can now be updated as follows:</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="header" minOccurs="1" maxOccurs="1" class="example.Header"&gt;
      &lt;field name="recordType" rid="true" literal="Header" /&gt;
      &lt;field name="fileDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
    &lt;record name="employee" minOccurs="0" maxOccurs="unbounded" class="example.Employee"&gt;
      &lt;field name="recordType" rid="true" literal="Detail" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
    &lt;record name="trailer" minOccurs="1" maxOccurs="1" class="example.Trailer"&gt;
      &lt;field name="recordType" rid="true" literal="Trailer" /&gt;
      &lt;field name="recordCount" /&gt;
    &lt;/record&gt;  
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>There are several new record and field attributes introduced in this mapping
file, so we'll explain each new attribute in turn.</p>

<p>First, a field used to identify a record must be configured as a <i>record identifier</i>
using <tt>rid="true"</tt>.
There is no limitation to the number of fields that can be used to identify a record,
but all fields where <tt>rid="true"</tt> must be satisfied before a record is
identified.  If there is no field configured as a record identifier, by default 
the record will always match.</p>
<pre class="file">
    &lt;record name="header" minOccurs="1" maxOccurs="1" class="example.Header"&gt;
      &lt;field name="recordType" <span class="highlight">rid="true"</span> literal="Header" /&gt;
      &lt;field name="fileDate" /&gt;
    &lt;/record&gt;
</pre>

<p>Second, all record identifying fields must have a matching validation rule configured.  In
our example, the literal value <tt>Header</tt> in the record type field is used to identify
the header record.  Literal values must match exactly and can be configured using the
<tt>literal</tt> field attribute.  Alternatively, record identifying fields may
use a regular expression to match field text using the <tt>regex</tt> field attribute.
</p>
<pre class="file">
    &lt;record name="header" minOccurs="1" maxOccurs="1" class="example.Header"&gt;
      &lt;field name="recordType" rid="true" <span class="highlight">literal="Header"</span> /&gt;
      &lt;field name="fileDate" /&gt;
    &lt;/record&gt;
</pre>

<p>Third, each record defines the minimum and maximum number of times it may
repeat using the attributes <tt>minOccurs</tt> and <tt>maxOccurs</tt>.  Based on
our configuration, exactly one header and trailer record is expected, while 
the number of detail records is unbounded.</p>
<pre class="file">
    &lt;record name="header" <span class="highlight">minOccurs="1" maxOccurs="1"</span> class="example.Header"&gt;
      &lt;field name="recordType" rid="true" literal="Header" /&gt;
      &lt;field name="fileDate" /&gt;
    &lt;/record&gt;
</pre>

<p>If <tt>minOccurs</tt> and/or <tt>maxOccurs</tt> are not set, the minimum occurrences 
of a record defaults to 0 and maximum occurrences is unbounded.</p>

<h3><a name="RecordOrdering">4.2.2. Record Ordering</a></h3>
<p>As explained in the previous section, a stream can support multiple record types.  By default,  
a <tt>BeanReader</tt> will read records in any order.  But if desired, BeanIO can enforce record
ordering using an <tt>order</tt> attribute on each record.  The <tt>order</tt> attribute can
be assigned any positive integer value greater than 0.  Records that are assigned the same number 
may be read from the stream in any order.  If <tt>order</tt> is set for one record, it must be
set for all other records (and groups) that share the same parent.</p>

<p>In our previous example, if we want enforce that the header record is the first record in the
file, the trailer is the last, and all detail records appear in the middle, the mapping
file could be changed as follows.  Using this configuration, if a detail record were to appear before the 
header record, the <tt>BeanReader</tt> will throw an <tt>UnexpectedRecordException</tt> when the detail
record is read out of order.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="header" <span class="highlight">order="1"</span> minOccurs="1" maxOccurs="1" class="example.Header"&gt;
      &lt;field name="recordType" rid="true" literal="Header" /&gt;
      &lt;field name="fileDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
    &lt;record name="employee" <span class="highlight">order="2"</span> minOccurs="0" maxOccurs="unbounded" class="example.Employee"&gt;
      &lt;field name="recordType" rid="true" literal="Detail" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
    &lt;record name="trailer" <span class="highlight">order="3"</span> minOccurs="1" maxOccurs="1" class="example.Trailer"&gt;
      &lt;field name="recordType" rid="true" literal="Trailer" /&gt;
      &lt;field name="recordCount" /&gt;
    &lt;/record&gt;  
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h3><a name="RecordGrouping">4.2.3. Record Grouping</a></h3>
<p>In some cases, a stream may be further divided into batches or groups of records.  
Continuing with our employee file, lets suppose employee detail records are batched by department,
where each group of employees has a department header and a department trailer record.  
Thus an input file may look something like this:</p>
<pre class="file">
Header,01012011
DeptHeader,Development
Detail,Joe,Smith,Developer,75000,10012009
Detail,Jane,Doe,Architect,80000,01152008
DeptTrailer,2
DeptHeader,Product Management
Detail,Jon,Anderson,Manager,85000,03182007
DeptTrailer,1
Trailer,2</pre>

<p>BeanIO allows you to define groups of records using a <tt>group</tt> element to wrap
the record types that belong to the group.  Groups
support the same <tt>order</tt>, <tt>minOccurs</tt>, and <tt>maxOccurs</tt> attributes, although
there meaning is applied to the entire group.  Once a record type is matched that belongs to a group,
all other records in that group where <tt>minOccurs</tt> is greater that 1, must be read from the stream
before the group may repeat or a different record can be read.  Our mapping file would now look like this:</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="header" order="1" minOccurs="1" maxOccurs="1" class="example.Header"&gt;
      &lt;field name="recordType" rid="true" literal="Header" /&gt;
      &lt;field name="fileDate" format="MMddyyyy" /&gt;
    &lt;/record&gt;
    <span class="highlight">&lt;group name="departmentGroup" order="2" minOccurs="0" maxOccurs"unbounded"&gt;</span>
      &lt;record name="deptHeader" order="1" minOccurs="1" maxOccurs="1" class="example.DeptHeader"&gt;
        &lt;field name="recordType" rid="true" literal="DeptHeader" /&gt;
        &lt;field name="departmentName" /&gt;
      &lt;/record&gt;
      &lt;record name="employee" order="2" minOccurs="0" maxOccurs="unbounded" class="example.Employee"&gt;
        &lt;field name="recordType" rid="true" literal="Detail" /&gt;
        &lt;field name="firstName" /&gt;
        &lt;field name="lastName" /&gt;
        &lt;field name="title" /&gt;
        &lt;field name="salary" /&gt;
        &lt;field name="hireDate" format="MMddyyyy" /&gt;
      &lt;/record&gt;
      &lt;record name="deptTrailer" order="3" minOccurs="1" maxOccurs="1" class="example.DeptTrailer"&gt;
        &lt;field name="recordType" rid="true" literal="DeptTrailer" /&gt;
        &lt;field name="employeeCount" /&gt;
      &lt;/record&gt;  
    <span class="highlight">&lt;/group&gt;</span>
    &lt;record name="trailer" order="3" minOccurs="1" maxOccurs="1" class="example.Trailer"&gt;
      &lt;field name="recordType" rid="true" literal="Trailer" /&gt;
      &lt;field name="departmentCount" /&gt;
    &lt;/record&gt;  
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>The stream definition itself is a record group with defaults <tt>minOccurs="0"</tt>
and <tt>maxOccurs="1"</tt>.  If you want your <tt>BeanReader</tt> to throw an exception if the stream 
is empty, simply change <tt>minOccurs</tt> to <tt>1</tt>, or if you want to allow the entire stream to repeat
indefinitely, simply change <tt>maxOccurs</tt> to <tt>unbounded</tt> as shown below.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv" <span class="highlight">minOccurs="1"</span> <span class="highlight">maxOccurs="unbounded"</span>&gt;
    &lt;!-- Record layout... --&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>



<h2><a name="FieldDefinitions">4.3. Fields</a></h2>
A record is made up of one or more fields, which are validated and bound to bean properties 
using the <tt>field</tt> element.  All fields must specify a <tt>name</tt> attribute, which  
by default, is used to get and set the field value from the bean object.

<p>Default getter and setter methods can be overridden using <tt>getter</tt> and <tt>setter</tt> 
attributes as shown below.  If a field is a constructor argument, <tt>setter</tt> can be set 
to '#N' where N is the position of the argument in the constructor starting at 1 (not shown).</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="stream1" format="csv"&gt;
    &lt;record name="record1" class="example.Record"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" <span class="highlight">setter="setSurname" getter="getSurname"</span>/&gt;
      &lt;field name="age" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>Fields found in a stream that do not map to a bean property can be declared,
but otherwise ignored, using the <tt>ignore</tt> field attribute.  Note that
any configured validation rules are still applied to ignored fields (not shown).</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="stream1" format="csv"&gt;
    &lt;record name="record1" class="example.Record"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="age" /&gt;
      &lt;field name="filler" <span class="highlight">ignore="true"</span> /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>By default, BeanIO expects fields to appear in a CSV, delimited or fixed length stream in the same order they
are declared in the mapping file.  If this is not the case, a <tt>position</tt> field attribute
can be configured for each field.  If a position is declared for one field, a position must be declared
for all other fields in the same record.  For delimited (and CSV) formatted streams, <tt>position</tt>
should be set to the index of the first occurrence of the field in the record, beginning at 0.  
For fixed length formatted streams, <tt>position</tt> should be set to the index of the first character
of the first occurrence of the field in the record, beginning at 0. </p>

<p>The following example shows how the position attribute can be used.  Although the fields are declared
in a different order, the record definition is identical to the previous example.  When positions are explicitly
configured for an input stream, there is no need to declare all fields in a record, unless desired 
for validation purposes.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="stream1" format="csv"&gt;
    &lt;record name="record1" class="example.Record"&gt;
      &lt;field name="filler" <span class="highlight">position="3"</span> ignore="true" /&gt;
      &lt;field name="lastName" <span class="highlight">position="1"</span> /&gt;
      &lt;field name="age" <span class="highlight">position="2"</span>/&gt;
      &lt;field name="firstName" <span class="highlight">position="0"</span> /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h3><a name="FieldTypeConversion">4.3.1. Field Type Conversion</a></h3>
<p>The property type of a field is determined by introspecting the bean object the field belongs to.
If the bean class is of type <tt>java.util.Map</tt>, BeanIO will assume the field is of type
<tt>java.lang.String</tt>, unless a field type is explicitly declared using a field's <tt>type</tt>
attribute.</p>
<p>The <tt>type</tt> attribute may be set to any fully qualified class name or to one of the 
supported type aliases below.  Type aliases are not case sensitive, and the same alias may be
used for primitive types.  For example, <tt>int</tt> and <tt>java.lang.Integer</tt>
bean properties will use the same type handler registered for the type <tt>java.lang.Integer</tt>,
or alias <tt>integer</tt> or <tt>int</tt>.</p>
<table class="indent">
<tr><th>Class Name</th><th>Primitive</th><th>Alias(es)</th></tr>
<tr><td>java.lang.String</td><td>-</td><td><tt>string</tt></td></tr>
<tr><td>java.lang.Boolean</td><td>boolean</td><td><tt>boolean</tt></td></tr>
<tr><td>java.lang.Byte</td><td>byte</td><td><tt>byte</tt></td></tr>
<tr><td>java.lang.Character</td><td>char</td><td><tt>character</tt><br /><tt>char</tt></td></tr>
<tr><td>java.lang.Short</td><td>short</td><td><tt>short</tt></td></tr>
<tr><td>java.lang.Integer</td><td>int</td><td><tt>integer</tt><br /><tt>int</tt></td></tr>
<tr><td>java.lang.Long</td><td>long</td><td><tt>long</tt></td></tr>
<tr><td>java.lang.Float</td><td>float</td><td><tt>float</tt></td></tr>
<tr><td>java.lang.Double</td><td>double</td><td><tt>double</tt></td></tr>
<tr><td>java.math.BigInteger</td><td>-</td><td><tt>biginteger</tt></td></tr>
<tr><td>java.math.BigDecimal</td><td>-</td><td><tt>bigdecimal</tt><br /><tt>decimal</tt></td></tr>
<tr><td>java.util.Date<sup>1</sup></td><td>-</td>
  <td>
    <tt>datetime</tt><br />
    <tt>date</tt><br />
    <tt>time</tt>
  </td>
</tr>
</table>
<p class="indent"><sup>1</sup> By default, the <tt>date</tt> alias is used for <tt>java.util.Date</tt> types that 
contain date information only, and the <tt>time</tt> alias is used for <tt>java.util.Date</tt> types that contain 
only time information.  Only the <tt>datetime</tt> alias can be used to replace the default type handler 
for the <tt>java.util.Date</tt> class.</p>

<p>Optionally, a <tt>format</tt> attribute can be used to pass a decimal format for <tt>java.lang.Number</tt> types, and
for passing a date format for <tt>java.util.Date</tt> types.  In the example below, the <tt>hireDate</tt> 
field uses the <tt>SimpleDateFormat</tt> pattern "yyyy-MM-dd", and the <tt>salary</tt> field uses the <tt>DecimalFormat</tt>
pattern "#,##0".  For more information about supported patterns, please reference the API documentation 
for Java's <tt>java.text.DecimalFormat</tt> and <tt>java.text.SimpleDateFormat</tt> classes.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="header" minOccurs="1" maxOccurs="1" class="map"&gt;
      &lt;field name="recordType" rid="true" literal="Header" /&gt;
      &lt;field name="fileDate" <span class="highlight">type="java.util.Date"</span> /&gt;
    &lt;/record&gt;
    &lt;record name="employee" minOccurs="0" maxOccurs="unbounded" class="map"&gt;
      &lt;field name="recordType" rid="true" literal="Detail" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" <span class="highlight">type="int" format="#,##0"</span> /&gt;
      &lt;field name="hireDate" <span class="highlight">type="date" format="yyyy-MM-dd"</span> /&gt;
    &lt;/record&gt;
    &lt;record name="trailer" minOccurs="1" maxOccurs="1" class="map"&gt;
      &lt;field name="recordType" rid="true" literal="Trailer" /&gt;
      &lt;field name="recordCount" <span class="highlight">type="int"</span> /&gt;
    &lt;/record&gt;  
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>




<h3><a name="CustomTypeHandlers">4.3.2. Custom Type Handlers</a></h3>
<p>Field type conversion is performed by a <i>type handler</i>.  BeanIO includes type handlers
for common Java types, or you can create your own type handler by implementing the 
<tt>org.beanio.types.TypeHandler</tt> interface shown below.
When writing a custom type handler, make sure to handle null values and empty strings.
Only one instance of your type handler is created, so if you plan to concurrently read or write
multiple streams, make sure your type handler is also thread safe.
</p>
<pre class="java">
package org.beanio.types;

public interface TypeHandler {
    public Object parse(String text) throws TypeConversionException;
    public String format(Object value);
    public Class&lt;?&gt; getType();
}</pre>

<p>The following example shows a custom type handler for the <tt>java.lang.Boolean</tt> class
and <tt>boolean</tt> primitive based on "Y" or "N" indicators.</p>
<pre class="java">
import org.beanio.types.TypeHandler;

public class YNTypeHandler implements TypeHandler {
    public Object parse(String text) throws TypeConversionException {
        return "Y".equals(text);
    }
    public String format(Object value) {
        return value != null &amp;&amp; ((Boolean)value).booleanValue() ? "Y" : "N";
    }
    public Class&lt;?&gt; getType() {
        return Boolean.class;
    }
}</pre>


<p>A type handler may be explicitly named using the <tt>name</tt> attribute, and/or registered for
all fields of a particular type by setting the <tt>type</tt> attribute.  The <tt>type</tt> attribute can
be set to the fully qualified class name or type alias of the class supported by the type handler.
To reference a named type handler, use the <tt>typeHandler</tt> field attribute when configuring
the field.</p>

<p>Many default type handlers included with BeanIO support customization through the use of 
one or more <tt>property</tt> elements, where the <tt>name</tt> attribute is a bean property of 
the type handler, and the <tt>value</tt> attribute is the property value.</p>

<p>Type handlers can be declared globally (for all streams in the mapping file) or for a specific stream.
Globally declared type handlers may optionally use a <tt>format</tt> attribute to narrow the type handler
scope to a specific stream format.</p>

<p>In the example below, the first <tt>DateTypeHandler</tt> is declared globally for all stream formats.  The
second <tt>DateTypeHandler</tt> overrides the first for <tt>java.util.Date</tt> types in an XML formatted stream, 
and the <tt>YNTypeHandler</tt> is declared only for the 'employeeFile' stream.  Stream specific type handlers 
override global type handlers when declared with the same name or for the same type.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;typeHandler <span class="highlight">type="java.util.Date"</span> class="org.beanio.types.DateTypeHandler"&gt;
    <span class="highlight">&lt;property name="pattern" value="MMddyyyy" /&gt;</span>
    <span class="highlight">&lt;property name="lenient" value="true" /&gt;</span>
  &lt;/typeHandler&gt;
  &lt;typeHandler type="java.util.Date" <span class="highlight">format="xml"</span> class="org.beanio.types.DateTypeHandler"&gt;
    &lt;property name="pattern" value="yyyy-MM-dd" /&gt;
  &lt;/typeHandler&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;typeHandler <span class="highlight">name="ynHandler"</span> class="example.YNTypeHandler" /&gt;
  
    &lt;record name="employee" minOccurs="0" maxOccurs="unbounded" class="map"&gt;
      &lt;field name="recordType" rid="true" literal="Detail" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" /&gt;
      &lt;field name="exempt" <span class="highlight">typeHandler="ynHandler"</span> /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h3><a name="RepeatingFields">4.3.3. Repeating Fields</a></h3>
<p>Repeating fields are also supported by BeanIO.  For example, lets assume our 
<tt>Employee</tt> bean object contains a list of account numbers.</p>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    <span class="highlight">List&lt;Integer&gt; accounts;</span>
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>And lets assume our input file now looks like this:</p>
<pre class="file">
Joe,Smith,Developer,75000,10012009
Chris,Johnson,Sales,80000,05292006<span class="highlight">,100012,200034,200045</span>
Jane,Doe,Architect,80000,01152008
Jon,Anderson,Manager,85000,03182007<span class="highlight">,333001</span></pre>

<p>In this example, the <tt>accounts</tt> bean property can be defined in the mapping file using a <tt>collection</tt> 
field attribute.  The <tt>collection</tt> attribute can be set to the fully qualified class name of
a <tt>java.util.Collection</tt> subclass, or to one of the collection type aliases below.</p>  
<table class="indent">
<tr><th>Class</th><th>Alias</th><th>Default Implementation</th></tr>
<tr><td>java.util.Collection</td><td><tt>collection</tt></td><td>java.util.ArrayList</td></tr>
<tr><td>java.util.List</td><td><tt>list</tt></td><td>java.util.ArrayList</td></tr>
<tr><td>java.util.Set</td><td><tt>set</tt></td><td>java.util.HashSet</td></tr>
<tr><td>(Java Array)</td><td><tt>array</tt></td><td>N/A</td></tr>
</table>

<p>Repeating fields can declare the number of occurrences of the field
using the <tt>minOccurs</tt> and <tt>maxOccurs</tt> field attributes.  If not declared, <tt>minOccurs</tt>
will default to 1, and <tt>maxOccurs</tt> will default to the <tt>minOccurs</tt> value or 1, whichever
is greater.  If the number of field occurences is variable (i.e. <tt>maxOccurs</tt> is greater than 
<tt>minOccurs</tt>), the field must be the last field in the record (for csv, delimited and fixed length
stream formats).
</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
      &lt;field name="accounts" type="int" <span class="highlight">collection="list" minOccurs="0" maxOccurs="unbounded"</span> /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>
<p>Note that a repeating field can not be used for record identification.</p>

<h3><a name="FixedLengthFields">4.3.4. Fixed Length Fields</a></h3>
<p>Fixed length fields require a little extra configuration than their delimited counterparts.  Let's
redefine our employee file example using the fixed length format below.
</p>
<div class="indent">
  <table>
    <tr><th>Position</th><th>Field</th><th>Format</th><th>Length</th></tr>
    <tr><td>0</td><td>First Name</td><td>Text</td><td>10</td></tr>
    <tr><td>10</td><td>Last Name</td><td>Text</td><td>10</td></tr>
    <tr><td>20</td><td>Job Title</td><td>Text</td><td>10</td></tr>
    <tr><td>30</td><td>Salary</td><td>Number</td><td>6</td></tr>
    <tr><td>36</td><td>Hire Date</td><td>Date (MMDDYYYY)</td><td>8</td></tr>
  </table>
</div>

<p>A fixed length version of the employee file might look like the following:</p>
<pre class="file">
Joe       Smith    Developer 07500010012009
Jane      Doe      Architect 08000001152008
Jon       Anderson Manager   08500003182007</pre>

<p>The length of a fixed length field must be configured using the <tt>length</tt> field attribute.
By default, fixed length fields are left justified and padded with spaces, but these settings can
be overridden using the <tt>padding</tt> and <tt>justify</tt> field attributes.  Field padding can
be set to any single character, and field justification can be set to <tt>left</tt> or <tt>right</tt>.
Using these attributes, our mapping file can now be updated as follows:  
</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" <span class="highlight">length="10"</span> /&gt;
      &lt;field name="lastName" <span class="highlight">length="10"</span> /&gt;
      &lt;field name="title" <span class="highlight">length="10"</span> /&gt;
      &lt;field name="salary" <span class="highlight">length="6" padding="0" justify="right"</span> /&gt;
      &lt;field name="hireDate" <span class="highlight">length="8"</span> format="MMddyyyy" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>The configured padding character is removed from the beginning of the field if right justified, or 
from the end of the field if left justified, until a character is found that does not match the padding
character.  If the entire field is padded, <tt>Number</tt> property types default to the padding character if 
it is a digit, and the padding character is ignored for <tt>Character</tt> types.  To illustrate this, 
some examples are shown in the table below.</p>
<table class="indent">
<tr>
  <th>Justify</th>
  <th>Type</th>
  <th>Padding</th>
  <th>Padded Text</th>
  <th>Unpadded Text</th>
</tr>
<tr>
  <td rowspan="4"><tt>left</tt></td>
  <td rowspan="2"><tt>String</tt></td>
  <td rowspan="2"><tt>"&nbsp;"</tt></td>
  <td>
    <tt>"George&nbsp;&nbsp;"</tt>
  </td>
  <td><tt>"George"</tt></td>
</tr>
<tr>
  <td><tt>"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</tt></td>
  <td><tt>""</tt></td>
</tr>
<tr>
  <td rowspan="2"><tt>Character</tt></td>
  <td rowspan="2"><tt>"&nbsp;"</tt></td>
  <td><tt>"A"</tt></td>
  <td><tt>"A"</tt></td>
</tr>
<tr>
  <td><tt>" "</tt></td>
  <td><tt>" "</tt></td>
</tr>
<tr>
  <td rowspan="5"><tt>right</tt></td>
  <td rowspan="5"><tt>Number</tt></td>
  <td rowspan="2"><tt>"0"</tt></td>
  <td><tt>"00123"</tt></td>
  <td><tt>"123"</tt></td>
</tr>
<tr>
  <td><tt>"00000"</tt></td>
  <td><tt>"0"</tt></td>
</tr>
<tr>
  <td rowspan="2"><tt>"9"</tt></td>
  <td><tt>"00000"</tt></td>
  <td><tt>"00000"</tt></td>
</tr>
<tr>
  <td><tt>"99999"</tt></td>
  <td><tt>"9"</tt></td>
</tr>
<tr>
  <td rowspan="1"><tt>"X"</tt></td>
  <td><tt>"XXXXX"</tt></td>
  <td><tt>""</tt></td>
</tr>
</table>

<p>The marshalling and unmarshalling behavior of null field values for a padded field is
further controlled using the <tt>required</tt> attribute.  If <tt>required</tt> is set to true, null
field values are marshalled by filling the field with the padding character.  If
<tt>required</tt> is set to false, a null field value is marshalled as spaces for fixed length
streams and an empty string for non-fixed length streams.  Similarly, if <tt>required</tt> is set to
false, spaces are unmarshalled to a null field value regardless of the padding character.
To illustrate this, the following table shows the field text for a right justified zero
padded 3 digit number.</p>

<table class="indent">
<tr>
  <th>Required</th>
  <th>Field Value</th>
  <th>Field Text<br /> (Fixed Length)</th>
  <th>Field Text<br />(CSV, Delimited, XML)</th>
</tr>
<tr>
  <td rowspan="2"><tt>true</tt></td>
  <td>0</td>
  <td>"<tt>000</tt>"</td>
  <td>"<tt>000</tt>"</td>
</tr>
<tr>
  <td>null</td>
  <td>"<tt>000</tt>"<sup>1</sup></td>
  <td>"<tt>000</tt>"<sup>1</sup></td>
</tr>
<tr>
  <td rowspan="2"><tt>false</tt></td>
  <td>0</td>
  <td>"<tt>000</tt>"</td>
  <td>"<tt>000</tt>"</td>
</tr>
<tr>
  <td>null</td>
  <td>"<tt>&nbsp;&nbsp;&nbsp;</tt>"</td>
  <td>""</td>
</tr>
</table>
<p class="indent"><sup>1</sup> Applies to marshalling only.  Unmarshalling "000" would
produce a field value of 0.</p>
<p>As hinted to above, padding settings can be applied to any field for any stream type.</p>


<h2><a name="Constants">4.4. Constants</a></h2>
<p>If a bean property does not map to a field in the stream, a constant property
value can still be set using a <tt>property</tt> element.  Like a field, all properties must 
specify a <tt>name</tt> attribute, which by default, is used to get and set the property value 
from the bean object.  Properties also require a <tt>value</tt> attribute for setting the textual
representation of the property value.  The value text is type converted using the same rules
and attributes (<tt>type</tt>, <tt>typeHandler</tt> and <tt>format</tt>) used for
field type conversion described above.  Collection type properties are not supported.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="map"&gt;
      <span class="highlight">&lt;property name="recordType" value="employee" /&gt;</span>
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>Constant properties may be useful in two scenarios:</p>
<ul>
<li>When reading an input stream (unmarshalling), if multiple records are mapped to the same bean class, such as a Map,
a property can be used to set a property, or a Map key, for identifying the record type without querying the 
<tt>BeanReader</tt>.</li>
<li>When writing an output stream (marshalling), a record mapping can be selected based on a record identifying
property value by setting <tt>rid</tt> to true.  This allows the same bean class to be unmarshalled to different
record types based on a property that may not exist in the output stream.</li>
</ul>

<h2><a name="Segments">4.5. Segments</a></h2>
<p>A segment is a group of fields within a record.  Segments are most often used to bind a group
of fields to a nested bean object or collection of bean objects, and are configured in a mapping
file using a <tt>segment</tt> element.</p>

<p>Prior to release 2.x, the <tt>bean</tt> element performed this task.  A <tt>segment</tt> supports
all the functionality of a <tt>bean</tt> element, but unlike the original <tt>bean</tt> element,
a <tt>segment</tt> is not required to be bound to a bean object.  This allows repeating segments
to be fully validated during unmarshalling, without necessarily binding the fields to a bean object.
An "unbound" segment also allows an arbitrary number of XML fields to be wrapped by other XML
nodes without creating bean objects that mirror the same hierarchy.</p>

<h3><a name="NestedBeans">4.5.1. Nested Beans</a></h3>
<p>As mentioned, a record can be divided into nested bean objects using 
a <tt>segment</tt> element.  First, let's suppose we store an address in our CSV employee
file, so that the record layout might look like this:</p>
<table class="indent">
  <tr><th>Position</th><th>Field</th><th>Format</th></tr>
  <tr><td>0</td><td>First Name</td><td>Text</td></tr>
  <tr><td>1</td><td>Last Name</td><td>Text</td></tr>
  <tr><td>2</td><td>Job Title</td><td>Text</td></tr>
  <tr><td>3</td><td>Salary</td><td>Number</td></tr>
  <tr><td>4</td><td>Hire Date</td><td>Date (MMDDYYYY)</td></tr>
  <tr><td>5</td><td>Street</td><td>Text</td></tr>
  <tr><td>6</td><td>City</td><td>Text</td></tr>
  <tr><td>7</td><td>State</td><td>Text</td></tr>
  <tr><td>8</td><td>Zip</td><td>Text</td></tr>
</table>

<p>Second, lets suppose we want to store address information in a new <tt>Address</tt>
bean object like the one below, and add an <tt>Address</tt> reference to our
<tt>Employee</tt> class.</p>
<pre class="java">
package example;

public class Address {
    String street;
    String city;
    String state;
    String zip;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    Address mailingAddress;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>With this information, we can now update our employee CSV mapping file to 
accomodate the nested <tt>Address</tt> object.  A <tt>segment</tt> must include a
<tt>name</tt> attribute, and may optionally provide a <tt>class</tt> attribute to bind its children
to a bean object.  If <tt>class</tt> is set, the attribute must be set to the fully
qualified class name of the bean object, or to <tt>map</tt>, or to the class name of 
any concrete <tt>java.util.Map</tt> implementation.  If the bean class is of type <tt>java.util.Map</tt>,
field values are stored in the Map using the configured field names for keys.
By default, the <tt>name</tt> attribute is used to determine the getter and setter on its parent 
bean or record.  Alternatively, <tt>getter</tt> or <tt>setter</tt> attributes can be used to override 
the default property name similar to a field property.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
      <span class="highlight">&lt;segment name="mailingAddress" class="example.Address"&gt;
        &lt;field name="street" /&gt;
        &lt;field name="city" /&gt;
        &lt;field name="state" /&gt;      
        &lt;field name="zip" /&gt;
      &lt;/segment&gt;</span>
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>If <tt>class</tt> is not set, fields will be automatically bound to the segment's parent bean object, which
would be the <tt>Employee</tt> object in the example above.</p>

<p>If needed, segments can be further divided into other segments.  There is no limit
to the number of nested levels that can be configured in a mapping file.</p>

<h3><a name="RepeatingSegments">4.5.2. Repeating Segments</a></h3>
<p>Similar to repeating fields, BeanIO supports repeating segments, which may be bound to a collection
of bean objects.  Continuing our previous
example, let's suppose the employee CSV file may contain 1 or more addresses for each employee.  Thus our 
<tt>Employee</tt> bean object might look like this:</p>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    List&lt;Address&gt; addressList;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>And our input file might look like this:</p>
<pre class="file">
Joe,Smith,Developer,75000,10012009,123 State St,Chicago,IL,60614
Jane,Doe,Architect,80000,01152008,456 Main St,Chicago,IL,60611,111 Michigan Ave,Chicago,IL,60611
Jon,Anderson,Manager,85000,03182007,1212 North Ave,Chicago,IL,60614</pre>

<p>In our mapping file, in order to bind a segment to a collection, simply set it's <tt>collection</tt> 
attribute to the fully qualified class name of a <tt>java.util.Collection</tt> subclass,
or to one of the collection type aliaes below.</p>
<table class="indent">
<tr><th>Class</th><th>Alias</th><th>Default Implementation</th></tr>
<tr><td>java.util.Collection</td><td><tt>collection</tt></td><td>java.util.ArrayList</td></tr>
<tr><td>java.util.List</td><td><tt>list</tt></td><td>java.util.ArrayList</td></tr>
<tr><td>java.util.Set</td><td><tt>set</tt></td><td>java.util.HashSet</td></tr>
<tr><td>(Java Array)</td><td><tt>array</tt></td><td>N/A</td></tr>
</table>

<p>Repeating segments can declare the number of occurrences
using the <tt>minOccurs</tt> and <tt>maxOccurs</tt> attributes.  If not declared, <tt>minOccurs</tt>
will default to 1, and <tt>maxOccurs</tt> will default to the <tt>minOccurs</tt> value or 1, whichever
is greater.  If the number of occurences is variable (i.e. <tt>maxOccurs</tt> is greater than 
<tt>minOccurs</tt>), the segment must be the last segment in the record (for CSV, delimited and fixed length
streams).</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" format="MMddyyyy" /&gt;
      &lt;segment name="addressList" <span class="highlight">collection="list" minOccurs="1" maxOccurs="unbounded"</span> class="example.Address"&gt;
        &lt;field name="street" /&gt;
        &lt;field name="city" /&gt;
        &lt;field name="state" /&gt;      
        &lt;field name="zip" /&gt;
      &lt;/segment&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>When working with repeating segments, there are a few restrictions to keep in mind:</p>
<ul>
  <li>Repeating segments must appear consecutively in the record.</li>
  <li>Every field in a repeating segment must be declared.  (There can be no field gaps in the segment configuration.)</li>
  <li>A repeating segment may not contain any repeating descendents with variable occurrences.</li>
  <li>Repeating fields or fields that belong to a repeating segment may not be used for record identification.</li>
</ul>




<h2><a name="StreamValidation">4.6. Stream Validation</a></h2>
<p>A <tt>BeanReader</tt> will throw an <tt>InvalidRecordException</tt> if a record or one of 
its fields fails a configured validation rule.  There are two types of errors reported
for an invalid record: record level errors and field level errors.  If a record level error occurs, 
further processing of the record is aborted and an excception is immediatedly thrown.  If a field level error is 
reported, the <tt>BeanReader</tt> will continue to process the record's other fields before throwing 
an exception.</p>

<p>When an <tt>InvalidRecordException</tt> is thrown, the exception will contain the reported
record and field level errors.  The following code shows how this information
can be accessed using the <tt>RecordContext</tt>.</p>

<pre class="java">
    BeanReader in;
    try {
        Object record = in.read();
        if (record != null) {
            <span class="comment">// process record...</span>
        }
    }
    catch (InvalidRecordException ex) {
        RecordContext context = ex.getRecordContext();
        if (context.hasRecordErrors()) {
            for (String error : context.getRecordErrors()) {
                <span class="comment">// handle record errors...</span>
            }
        }
        if (context.hasFieldErrors()) {
            for (String field : context.getFieldErrors().keySet()) {
                for (String error : context.getFieldErrors(field)) {
                    <span class="comment">// handle field error...</span>
                }
            }
        }
    }               
}
</pre>

<p>Alternatively, it may be simpler to register a <tt>BeanReaderErrorHandler</tt> for handling
non-fatal exceptions.  The example below shows how invalid records could be written to a 
reject file by extending <tt>BeanReaderErrorHandlerSupport</tt>.  (Note that the example assumes the mapping
file does not bind a record group to a bean object.)
</p>

<pre class="java">
    BeanReader input;
    BufferedWriter rejects;
    try {
        input.setErrorHandler(new BeanReaderErrorHandlerSupport() {
            public void invalidRecord(InvalidRecordException ex) throws Exception {
                rejects.write(ex.getRecordContext().getRecordText());
                rejects.newLine();
            }
        });
        
        Object record = null;
        while ((record = input.read()) != null) {
            <span class="comment">// process a valid record</span>
        }
        
        rejects.flush();
    }
    finally {
        input.close();
        rejects.close();
    }
</pre>

<p>Record and field level error messages can be customized and localized through
the use of resource bundles.  A resource bundle is
configured at the stream level using the <tt>resourceBundle</tt> attribute as
shown below.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;typeHandler type="java.util.Date" class="org.beanio.types.DateTypeHandler"&gt;
    &lt;property name="pattern" value="MMddyyyy" /&gt;
  &lt;/typeHandler&gt;

  &lt;stream name="employeeFile" format="csv" <span class="highlight">resourceBundle="example.messages"</span> &gt;
    &lt;record name="employee" class="map"&gt;
      &lt;field name="recordType" rid="true" literal="Detail" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>Record level error messages are retrieved using the following prioritized 
list of keys.  If a message is not configured under the name of the first key, the next key
will be tried until a message is found, or a default message is used.</p>
<ol>
  <li><tt>recorderror.[record name].[rule]</tt></li>
  <li><tt>recorderror.[rule]</tt></li>
</ol>
<p>Similarly, field level error messages are retrieved using the following priortized list of keys:</p>
<ol>
  <li><tt>fielderror.[record name].[field name].[rule]</tt></li>
  <li><tt>fielderror.[record name].[rule]</tt></li>
  <li><tt>fielderror.[rule]</tt></li>
</ol>  
<p>More descriptive or localized labels can be configured for record and field names using the keys 
<tt>label.[record name]</tt> and <tt>label.[record name].[field name]</tt>
respectively.</p>

<p>For example, the following resource bundle could be used to customize
a few error messages for the employee file.</p>
<pre class="file">
<span class="comment"># 'employee' record label:</span>
label.employee = Employee Record
<span class="comment"># 'firstName' field label:</span>
label.employee.firstName = First Name Field
<span class="comment"># Unidentified record error message:</span>
recorderror.unidentified = Unidentified record at line {0}
<span class="comment"># Type conversion error message for the 'hireDate' field:</span>
fielderror.employee.hireDate.type = Invalid date format
<span class="comment"># Maximum field length error message for all fields:</span>
fielderror.maxLength = Maximum field length exceeded for {3}
</pre>

<p>Error messages are formatted using a <tt>java.text.MessageFormat</tt>.  Depending
on the validation rule that was violated, different parameters are passed to the 
<tt>MessageFormat</tt>.  
<a href="#B">Appendix B</a> documents the parameters passed to the <tt>MessageFormat</tt> for each
validation rule.</p>


<h3><a name="RecordValidation">4.6.1. Record Validation</a></h3>
<p>The following record level validation rules may be configured on a <tt>record</tt> element.
</p>
<table>
<tr><th>Attribute</th><th>Argument Type</th><th>Description</th></tr>
<tr>
  <td><tt>minLength</tt></td>
  <td>Integer</td>
  <td>Validates the record contains at least <tt>minLength</tt> fields for delimited and CSV formatted streams,
    or has at least <tt>minLength</tt> characters for fixed length formatted streams.</td>
</tr>
<tr>
  <td><tt>maxLength</tt></td>
  <td>Integer</td>
  <td>Validates the record contains at most <tt>maxLength</tt> fields for delimited and CSV formatted streams,
    or has at most <tt>maxLength</tt> characters for fixed length formatted streams.</td>
</tr>
</table>

<h3><a name="FieldValidation">4.6.2. Field Validation</a></h3>
<p>BeanIO supports several common field validation rules when reading an input stream.  All field 
validation rules are validated against the field text before type conversion.  When field trimming 
is enabled, <tt>trim="true"</tt>, all validations are performed
after the field's text has first been trimmed.  Field validations are ignored when 
writing to an output stream.
</p>
<p>The following table lists supported field attributes for validation.</p>
<table>
<tr><th>Attribute</th><th>Argument Type</th><th>Description</th></tr>
<tr>
  <td><tt>required</tt></td>
  <td>Boolean</td>
  <td>When set to <tt>true</tt>, validates the field is present and the field text is 
  not the empty string.</td>
</tr>
<tr>
  <td><tt>minLength</tt></td>
  <td>Integer</td>
  <td>Validates the field text is at least N characters.</td>
</tr>
<tr>
  <td><tt>maxLength</tt></td>
  <td>Integer</td>
  <td>Validates the field text does not exceed N characters.</td>
</tr>
<tr>
  <td><tt>literal</tt></td>
  <td>String</td>
  <td>Validates the field text exactly matches the literal value.</td>
</tr>
<tr>
  <td><tt>regex</tt></td>
  <td>String</td>
  <td>Validates the field text matches the given regular expression pattern.</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>String</td>
  <td>Validates the minimum occurrences of the field in a stream.  If the field is present in the stream, 
    <tt>minOccurs</tt> is satisfied, and the <tt>required</tt> setting determines whether a value is required.</td>
</tr>
</table>


<h2><a name="Templates">4.7. Templates</a></h2>
<p>When a common set of fields is used by multiple record types, configuration may
be simplified using templates.  A template is a reusable list of components (segments, fields,
and properties/constants) that can be included by a record, segment or other template.
The following example illustrates some of the ways a template can be used:</p>

<pre class="file">
&lt;beanio&gt;

  <span class="highlight">&lt;template name="address"&gt;
    &lt;field name="street1" /&gt;
    &lt;field name="street2" /&gt;
    &lt;field name="city" /&gt;
    &lt;field name="state" /&gt;
    &lt;field name="zip" /&gt;
  &lt;/template&gt;</span>

  &lt;template name="employee"&gt;
    &lt;field name="firstName" /&gt;
    &lt;field name="lastName" /&gt;
    &lt;field name="title" /&gt;
    &lt;field name="salary" /&gt;
    &lt;field name="hireDate" format="MMddyyyy" /&gt;
    &lt;segment name="mailingAddress" <span class="highlight">template="address"</span> class="example.Address" /&gt;
  &lt;/template&gt;
      
  &lt;stream name="employeeFile" format="csv"&gt;
    &lt;record name="employee" <span class="highlight">template="employee"</span> class="example.Employee" /&gt;
  &lt;/stream&gt;

  &lt;stream name="addressFile" format="csv"&gt;
    &lt;record name="address" class="example.Address"&gt;
      &lt;field name="location" /&gt;
      <span class="highlight">&lt;include template="address"/&gt;</span>
      &lt;field name="attention" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;

&lt;/beanio&gt;</pre>

<p>Templates are essentially copied into their destination using the <tt>include</tt> element.
For convenience, <tt>record</tt> and <tt>segment</tt> elements support a <tt>template</tt> attribute
which includes the template before any other children.</p>

<p>The <tt>include</tt> element can optionally specify a positional offset for included fields
using the <tt>offset</tt> attribute.  The following example illustrates this behavior.  Even when
using templates, remember that <tt>position</tt> must be declared for all fields or none.</p>

<pre class="file">
&lt;beanio&gt;

  &lt;template name="address"&gt;
    &lt;field name="street1" position="0" /&gt;
    &lt;field name="street2" position="1" /&gt;
    &lt;field name="city" position="2" /&gt;
    &lt;field name="state" position="3" /&gt;
    &lt;field name="zip" position="4" /&gt;
  &lt;/template&gt;

  &lt;stream name="addressFile" format="csv"&gt;
    &lt;record name="address" class="example.Address"&gt;
      &lt;field name="location" position="0" /&gt;
      &lt;include template="address" <span class="highlight">offset="1"</span>/&gt;
      &lt;field name="attention" position="6" /&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;

&lt;/beanio&gt;</pre>


<h2><a name="AdvancedTopics">4.8. Advanced Topics</a></h2>

<h3><a name="RecordGroups">4.8.1.  Mapping Bean Objects that Span Multiple Records</a></h3>
<p>Since release 2.0, BeanIO supports the binding of multiple consecutive records to a single 
bean object.  This can be achieved by assigning a bean class to a <tt>stream</tt> or
<tt>group</tt> containing the <tt>record</tt> configurations bound to the bean.</p>
<p>Let's suppose we are reading a CSV input file of orders that contains an order, followed by the customer
that placed the order, followed by a detailed list of items that make up the order.  A sample
input file might look like this:</p>

<pre class="file">
Order,101,2012-02-01,5.00
Customer,John,Smith
Item,Apple,2,2.00
Item,Orange,1,1.00
Order,102,2012-02-01,3.00
Customer,Jane,Johnson
Item,Ham,1,3.00
</pre>

<p>Let's then suppose we want to read the following <tt>Order</tt> class from the stream,
which contains a reference to <tt>Customer</tt> and <tt>Item</tt> classes.  (For brevity,
getters and setters are not shown.)</p>

<pre class="java">
package example;
import java.util.Date;

public class Order {
    String id;
    Date date;
    BigDecimal amount;
    Customer customer;
    List&lt;Item&gt; items;
}

public class Customer {
    String firstName;
    String lastName;
}

public class Item {
    String name;
    int quantity;
    BigDecimal amount;
}</pre>

<p>Now to read and write <tt>Order</tt> objects from our example stream, the following mapping file can be used:</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="orders" format="csv"&gt;
    &lt;group name="order" <span class="highlight">class="example.Order"</span> minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;record name="orderRecord" order="1" minOccurs="1"&gt;
        &lt;field name="recordType" rid="true" literal="Order" ignore="true" /&gt;
        &lt;field name="id" /&gt;
        &lt;field name="date" format="yyyy-MM-dd" /&gt;
        &lt;field name="amount" /&gt;
      &lt;/record&gt;
      &lt;record name="customer" <span class="highlight">class="example.Customer"</span> order="2" minOccurs="1"&gt;
        &lt;field name="recordType" rid="true" literal="Customer" ignore="true" /&gt;
        &lt;field name="firstName" /&gt;
        &lt;field name="lastName" /&gt;
      &lt;/record&gt;      
      &lt;record name="items" <span class="highlight">class="example.Item" collection="list"</span> order="3" minOccurs="1" maxOccurs="unbounded"&gt;
        &lt;field name="recordType" rid="true" literal="Item" ignore="true" /&gt;
        &lt;field name="name" /&gt;
        &lt;field name="quantity" /&gt;
        &lt;field name="amount" /&gt;
      &lt;/record&gt;
    &lt;/group&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>By configuring a <tt>class</tt> on a <tt>group</tt> component, BeanIO will automatically marshal or unmarshal all of
the group's descendants in a single call to read or write from the stream.  Also note that by not configuring a <tt>class</tt>
on a <tt>record</tt>, in this case our "orderRecord", the fields are instead set on the bean class assigned to it's
parent group.  Finally, repeating records can be aggregated into a collection using a <tt>collection</tt> attribute
at the <tt>record</tt> level, as used for the "items" record.  If necessary, <tt>getter</tt> and <tt>setter</tt>
attributes can be configured on a <tt>record</tt> component as well.</p>

<p>If any record included in a group bound to a bean object is invalid, an <tt>InvalidRecordException</tt> is
thrown, but only after reading all the other records in the group.  In such cases, the <tt>InvalidRecordException</tt>
will contain <tt>RecordContext</tt> objects for every record in the group read from the stream.  If multiple records
in the group are invalid, only one <tt>InvalidRecordException</tt> is thrown.</p>

<p>If a malformed or unidentified record is read from the stream while unmarsahalling a record group, an exception
is immediately thrown, and the <tt>BeanReader</tt> will most likely <b>not</b> be able to recover.  For this reason,
when unmarshalling untrusted sources, it is recommended that you read the stream twice, using the first pass
to validate the integrity of the file including syntax, record identification, record ordering, possible header/trailer 
counts, etc.  For example, the following mapping file might be used to validate our orders file.</p>

<pre class="file">
&lt;beanio&gt;

  &lt;stream name="orders-validation" format="csv"&gt;
    &lt;group name="order" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;record name="orderRecord" order="1" minOccurs="1"&gt;
        &lt;field name="recordType" rid="true" literal="Order" ignore="true" /&gt;
      &lt;/record&gt;
      &lt;record name="customer" order="2" minOccurs="1"&gt;
        &lt;field name="recordType" rid="true" literal="Customer" ignore="true" /&gt;
      &lt;/record&gt;      
      &lt;record name="items" order="3" minOccurs="1" maxOccurs="unbounded"&gt;
        &lt;field name="recordType" rid="true" literal="Item" ignore="true" /&gt;
      &lt;/record&gt;
    &lt;/group&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>In this case, we are validating syntax, record ordering and record identification for the entire file
in a single call to <tt>beanReader.read()</tt>, while leaving other record and field level validations 
for unmarshalling, which can be caught and handled without worrying whether the <tt>BeanReader</tt>
will be able to recover.</p>

<!-- 

  5.0. MAPPING XML FORMATTED STREAMS
  
 -->
<h1><a name="MappingXmlStreams">5.0. Mapping XML Streams</a></h1>
<p>This section provides further details for using BeanIO to marshall and unmarshall
Java objects to and from XML formatted streams.   This section assumes you are already familiar with 
the mapping file concepts documented in previous sections.</p>
<h2><a name="XmlIntroduction">5.1. Introduction</a></h2>
<p>BeanIO is similar to other OXM (Object to XML Mapping) libraries, except that it is also capable
of marshalling and unmarshalling extremely large XML files by reading and writing Java beans one
record at a time.  BeanIO uses a streaming XML (StAX) parser to read and write XML, and will never 
hold more than the minimum amount of XML in memory needed to marshall or unmarshall a single bean object.
That said, it is still possible to run out of memory (heap space) with poorly designed XML documents and/or misconfigured
mapping files.</p>

<h3><a name="MyFirstXmlStream">5.1.1. My First XML Stream</a></h3>
<p>Before diving into the details, let's start with a basic example using the employee input file
from <a href="#MyFirstStream">Section 2.1</a> after it's been converted to XML (shown below).</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Joe&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;title&gt;Developer&lt;/title&gt;
    &lt;salary&gt;75000&lt;/salary&gt;
    &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Jane&lt;/firstName&gt;
    &lt;lastName&gt;Doe&lt;/lastName&gt;
    &lt;title&gt;Architect&lt;/title&gt;
    &lt;salary&gt;80000&lt;/salary&gt;
    &lt;hireDate&gt;2008-01-15&lt;/hireDate&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Jon&lt;/firstName&gt;
    &lt;lastName&gt;Andersen&lt;/lastName&gt;
    &lt;title&gt;Manager&lt;/title&gt;
    &lt;salary&gt;85000&lt;/salary&gt;
    &lt;hireDate&gt;2007-03-18&lt;/hireDate&gt;
  &lt;/employee&gt;
&lt;/employeeFile&gt;
</pre>

<p>In this example, let's suppose we are unmarshalling the XML employee file into the same
<tt>Employee</tt> bean object from Section 2.1 and repeated below.</p>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>Our original mapping file from Section 2.1 can now be updated to parse XML instead of
CSV with only two minor changes.  First, the stream format is changed to
<tt>xml</tt>.  And second, the hire date field format is removed and replaced with 
<tt>type="date"</tt>.  With XML, the date format does not need to be explicity declared
because it conforms to the W3C XML Schema date syntax.  (This will be further explained
in <a href="#XmlTypeConversion">Section 5.7.1</a>).</p>
<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2012/03" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd"&gt;

  &lt;stream name="employeeFile" format="<span class="highlight">xml</span>"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" <span class="highlight">type="date"</span> /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
&lt;/beanio&gt;</pre>

<p>That's it!  No Java code changes are required, and as before, <tt>Employee</tt> bean objects
will be unmarshalled from the XML input stream each time <tt>beanReader.read()</tt> is called.</p>
<p>And also as before, <tt>Employee</tt> objects can be marshalled to an XML output stream using 
<tt>beanWriter.write(Object)</tt>.  However, please note that when marshalling/writing XML, 
it is even more important to call <tt>beanWriter.close()</tt> so that the XML document can be 
properly completed.</p>


<h3><a name="XmlValidation">5.1.2. A Note on XML Validation</a></h3>
<p>Because BeanIO is built like a pull parser, it does not support XML validation against a DTD
or XML schema.  Where this functionality is needed, it is recommended to make two passes on the
input document.  The first pass can use a SAX parser or other means to validate the XML, and the
second pass can use BeanIO to parse and process bean objects read from the document.</p>


<h2><a name="XmlNames">5.2. XML Names</a></h2>
<p>Each BeanIO mapping component (stream, group, record, segment and field), is mapped to an XML
element with the same local name.  If the name of the stream, group, etc. does not match the XML
element name, the <tt>xmlName</tt> attribute can be used.  For example, if the name of the root element in the previous
example's employee file is changed from "employeeFile" to "employees", and "title" was renamed "position",
the mapping file could be updated as shown below.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml" <span class="highlight">xmlName="employees"</span>&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" <span class="highlight">xmlName="position"</span> /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h2><a name="XmlNamespaces">5.3. XML Namespaces</a></h2>
<p>XML namespaces can be enabled through the use of the <tt>xmlNamespace</tt> attribute
on any mapping component (stream, group, record, segment or field).  By default, all mapping elements 
inherit their namespace (or lack thereof) from their parent.  When a namespace is delcared, the local
name <i>and</i> namespace must match when unmarshalling XML, and appropriate namespace declarations
are included when marshalling bean objects.  For example, let's suppose our employee file contains
namespaces as shown below.</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile xmlns="http://example.com/employeeFile" xmlns:n="http://example.com/name"&gt;
  &lt;e:employee xmlns:e="http://example.com/employee"&gt;
    &lt;n:firstName&gt;Joe&lt;/n:firstName&gt;
    &lt;n:lastName&gt;Smith&lt;/n:lastName&gt;
    &lt;e:title&gt;Developer&lt;/e:title&gt;
    &lt;e:salary&gt;75000&lt;/e:salary&gt;
    &lt;e:hireDate&gt;2009-10-12&lt;/e:hireDate&gt;
  &lt;/e:employee&gt;
  .
  .
  .
&lt;/employeeFile&gt;
</pre>

<p>To unmarshall the file using namespaces, and to marshall Employee bean objects in the same fashion
as they appear above, the following mapping file can be used.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml" <span class="highlight">xmlNamespace="http://example.com/employeeFile"</span>&gt;
    &lt;parser&gt;
      <span class="highlight">&lt;property name="namespaces" value="n http://example.com/name"/&gt;</span>
    &lt;/parser&gt;
    &lt;record name="employee" class="example.Employee" <span class="highlight">xmlNamespace="http://example.com/employee"</span> <span class="highlight">xmlPrefix="e"</span>&gt;
      &lt;field name="firstName" <span class="highlight">xmlNamespace="http://example.com/name"</span> /&gt;
      &lt;field name="lastName" <span class="highlight">xmlNamespace="http://example.com/name"</span> /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>From this example, the following behavior can be observed:</p>
<ul>
<li>An <tt>xmlPrefix</tt> attribute can be used to assign a namespace prefix anywhere a <tt>xmlNamespace</tt> is declared.  
 <ul>
 <li>If a prefix is configured, the namespace is assigned to the prefix and the prefix is used
   from that point forward.  This can be seen on the 'employee' element (<tt>record</tt> configuration).</li>
 <li>If a prefix is not configured, a namespace declaration will replace the default namespace.  This can
   be seen on the 'employeeFile' element (<tt>stream</tt> configuration).</li>
 </ul>
</li>
<li>As previously mentioned, namespace are by default inherited from parent mapping elements.  This
  can be seen on the 'title', 'salary' and 'hireDate' elements (<tt>field</tt> configurations).</li>
<li>Namespaces can be eagerly declared on the root element using the writer's <tt>namespaces</tt> property.
  Multiple namespaces can be declared with space delimiters such as '<i>prefix1 namespace1 prefix2 namespace2...</i>'.
</li>
</ul>

<p>BeanIO also supports a special wildcard namespace.  If <tt>xmlNamespace</tt> is set to '*', any namespace
is allowed when unmarshalling XML, and no namespace declaration will be made when marshalling XML.</p>

<p>The following table summarizes namespace configuration options and their effect on the configured
element and a child that inherits it's parent namespace.</p>
<table class="indent">
<tr>
  <th>Mapping Configuration</th>
  <th>Marshalled Element And Child</th>
</tr>
<tr>
  <td><pre>[None]</pre></td>
  <td><pre>&lt;element&gt;
  &lt;child/&gt;
&lt;/element&gt;</pre></td>
</tr>
<tr>
  <td><pre>xmlNamespace="*"</pre></td>
  <td><pre>&lt;element&gt;
  &lt;child/&gt;
&lt;/element&gt;</pre></td>
</tr>
<tr>
  <td><pre>xmlNamespace=""</pre></td>
  <td><pre>&lt;element xmlns=""&gt;
  &lt;child/&gt;
&lt;/element&gt;</pre></td>
</tr>
<tr>
  <td><pre>xmlNamespace="http://example.com"</pre></td>
  <td><pre>&lt;element xmlns="http://example.com"&gt;
  &lt;child/&gt;
&lt;/element&gt;</pre></td>
</tr>
<tr>
  <td><pre>xmlNamespace="http://example.com" xmlPrefix="e"</pre></td>
  <td><pre>&lt;e:element xmlns="http://example.com"&gt;
  &lt;e:child/&gt;
&lt;/e:element&gt;</pre></td>
</tr>
</table>

<h2><a name="XmlStreams">5.4. Streams</a></h2>
<p>When unmarshalling multiple records from an XML document, the <tt>stream</tt> configuration 
is mapped to the root element in the XML formatted stream.  This default behavior has been 
demonstrated in previous examples.  If on the other hand, an XML document contains only a
single record, the document can be fully read or written by setting the <tt>stream</tt>
configuration's <tt>xmlType</tt> attribute to <tt>none</tt>.  This behavior is similar to
other OXM libraries that marshall or unmarshall one bean object per XML document.</p>

<p>For example, if BeanIO was used to unmarshall a single employee record submitted via a web
service, the XML document might look like the following.  Notice there is no 'employeeFile'
root element for containing multiple employee records.</p>
<pre class="file">
&lt;employee&gt;
  &lt;firstName&gt;Joe&lt;/firstName&gt;
  &lt;lastName&gt;Smith&lt;/lastName&gt;
  &lt;title&gt;Developer&lt;/title&gt;
  &lt;salary&gt;75000&lt;/salary&gt;
  &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
&lt;/employee&gt;
</pre>

<p>In this example, the following highlighted changes can be made to our mapping file to
allow BeanIO to unmarshall/marshall a single employee record.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml" <span class="highlight">xmlType="none"</span>&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h2><a name="XmlGroups">5.5. Groups</a></h2>
<p>Like other mapping elements, groups are also mapped to XML elements by default.
Or if a group is used only for control purposes, the group's <tt>xmlType</tt> attribute
can be set to <tt>none</tt>.</p>

<h2><a name="XmlRecords">5.6. Records</a></h2>
<p>A record is always mapped to an XML element.  As we've seen before, records are matched
based on their group context and configured record identifying fields.  XML records are further
matched using their XML element name, as defined
by <tt>xmlName</tt>, or if not present, <tt>name</tt>.  Other than configured record identifying fields,
segment and field names declared within the record are not used to identify records.</p>

<p>For example, let's suppose our employee file differentiated managers using 'manager' tags.</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Joe&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;title&gt;Developer&lt;/title&gt;
    &lt;salary&gt;75000&lt;/salary&gt;
    &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
  &lt;/employee&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Jane&lt;/firstName&gt;
    &lt;lastName&gt;Doe&lt;/lastName&gt;
    &lt;title&gt;Architect&lt;/title&gt;
    &lt;salary&gt;80000&lt;/salary&gt;
    &lt;hireDate&gt;2008-01-15&lt;/hireDate&gt;
  &lt;/employee&gt;
  &lt;manager&gt;
    &lt;firstName&gt;Jon&lt;/firstName&gt;
    &lt;lastName&gt;Andersen&lt;/lastName&gt;
    &lt;title&gt;Manager&lt;/title&gt;
    &lt;salary&gt;85000&lt;/salary&gt;
    &lt;hireDate&gt;2007-03-18&lt;/hireDate&gt;
  &lt;/manager&gt;
&lt;/employeeFile&gt;
</pre>

<p>To bind managers to a new <tt>Manager</tt> bean we could use the following
mapping configuration.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
    &lt;/record&gt;
    <span class="highlight">&lt;record name="manager" class="example.Manager"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
    &lt;/record&gt;</span>
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<h2><a name="XmlFields">5.7. Fields</a></h2>
<p>A field is mapped to XML using the field's <tt>xmlType</tt> attribute, which defaults to <tt>element</tt>.
The field XML type can be set to <tt>element</tt>, <tt>attribute</tt>, <tt>text</tt>, or <tt>none</tt>.  The following
table illustrates possible configurations, except for <tt>none</tt> which is not covered here.</p>

<table class="indent">
<tr>
  <th>Record Definition</th>
  <th>Sample Record</th>
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="element"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person&gt;
  &lt;name&gt;John&lt;/name&gt;
&lt;/person&gt;</pre>
</td>  
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="attribute"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person name="John"/&gt;</pre>
</td>  
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="text"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person&gt;John&lt;/person&gt;</pre>
</td>  
</tr>
</table>

<h3><a name="XmlTypeConversion">5.7.1. Field Type Conversion</a></h3>
<p>Field type conversion works the same way for XML formatted streams as it does for other formats.  However,
several default type handlers are overridden specifically for XML formatted streams to
conform with W3C XML Schema built-in data types according to this 
<a href="http://www.w3.org/TR/xmlschema-2/">specification</a>.
The following table summarizes overriden type handlers:</p>
<table class="indent">
<tr>
  <th>Class or Type Alias</th>
  <th>XML Schema Data Type</th>
  <th>Example</th>
</tr>
<tr>
  <td><tt>date</tt></td>
  <td><a href="http://www.w3.org/TR/xmlschema-2/#date">date</a></td>
  <td><tt>2011-01-01</tt></td>
</tr>
<tr>
  <td><tt>datetime</tt> or java.util.Date</td>
  <td><a href="http://www.w3.org/TR/xmlschema-2/#dateTime">dateTime</a></td>
  <td><tt>2011-01-01T15:14:13</tt></td>
</tr>
<tr>
  <td><tt>time</tt></td>
  <td><a href="http://www.w3.org/TR/xmlschema-2/#time">time</a></td>
  <td><tt>15:14:13</tt></td>
</tr>
<tr>
  <td><tt>boolean</tt></td>
  <td><a href="http://www.w3.org/TR/xmlschema-2/#boolean">boolean</a></td>
  <td><tt>true</tt></td>
</tr>
</table>

<p>Like other type handlers, XML specific type handlers can be customized or completely
replaced.  Please consult BeanIO javadocs for customization details.</p>

<h3><a name="NullFields">5.7.2. Marshalling Null Field Values</a></h3>
<p>The <tt>nillable</tt> and <tt>minOccurs</tt> field attributes control how a null field value is marshalled.  
If <tt>minOccurs</tt> is 0, an element or attribute is not marshalled for the field.
If an element type field has <tt>nillable</tt> set to <tt>true</tt> and <tt>minOccurs</tt> set to 1, the W3C XML Schema 
Instance attribute <tt>nil</tt> is set to <tt>true</tt>.</p>

<p>This behavior is illustrated in the following table.</p>
<table class="indent">
<tr>
  <th>Field Type</th>
  <th>Record Definition</th>
  <th>Marshalled Record<br/>(Field Value is Null)</th>
</tr>
<tr>
  <td rowspan="3"><pre>element</pre></td>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" /&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person&gt;
  &lt;name/&gt;
&lt;/person&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">minOccurs="0"</span> /&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person/&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">nillable="true"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person&gt;
  &lt;name xsi:nil="true"/&gt;
&lt;/person&gt;</pre>
</td>
</tr>
<tr>
  <td rowspan="2"><pre>attribute</pre></td>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="attribute"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person/&gt;</pre>
</td>  
</tr>
<tr>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="attribute" minOccurs="1"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person name=""/&gt;</pre>
</td>  
</tr>
<tr>
  <td><pre>text</pre></td>
  <td><pre>&lt;record name="person" class="map"&gt;
  &lt;field name="name" <span class="highlight">xmlType="text"</span>/&gt;
&lt;/person&gt;</pre>
  </td>
  <td><pre>&lt;person/&gt;</pre>
</td>  
</tr>
</table>

<h2><a name="XmlSegments">5.8. Segments</a></h2>
<p>A segment can be used to bind a group of fields to a nested bean object... TODO</p>

<h3><a name="XmlNestedBeans">5.8.1. Nested Beans</a></h3>
<p>Segments can be used to bind a group of fields to a bean object.  The <tt>xmlType</tt> assigned to 
the segment determines the format of the XML.  Possible values are <tt>element</tt> (default) and <tt>none</tt>.
The difference can be explored using the Address and Employee beans defined in Section 4.4 and repeated here.</p>
<pre class="java">
package example;

public class Address {
    String street;
    String city;
    String state;
    String zip;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    Address mailingAddress;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>By default, a segment's <tt>xmlType</tt> is set to <tt>element</tt>, so
it is not necessary to declare it in the mapping file below.</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
      &lt;segment name="mailingAddress" class="example.Address" <span class="highlight">xmlType="element"</span>&gt;
        &lt;field name="street" /&gt;
        &lt;field name="city" /&gt;
        &lt;field name="state" /&gt;      
        &lt;field name="zip" /&gt;
      &lt;/segment&gt;
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>This mapping configuration can be used to process the sample XML document below.  When
a segment is mapped to an XML element, <tt>nillable</tt> and <tt>minOccurs</tt> will control
the marshalling behavior of null bean objects in the same fashion as a field (see <a href="#NullFields">Section 5.7.2</a>).
</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Joe&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;title&gt;Developer&lt;/title&gt;
    &lt;salary&gt;75000&lt;/salary&gt;
    &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
    &lt;mailingAddress&gt;
      &lt;street&gt;123 Main Street&lt;/street&gt;
      &lt;city&gt;Chicago&lt;/city&gt;
      &lt;state&gt;IL&lt;/state&gt;
      &lt;zip&gt;12345&lt;/zip&gt;
    &lt;/mailingAddress&gt;
  &lt;/employee&gt;
  .
  .
  .
&lt;/employeeFile&gt;
</pre>

<p>Alternatively, if the segment's <tt>xmlType</tt> is set to <tt>none</tt>,
the following XML document can be processed.</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Joe&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;title&gt;Developer&lt;/title&gt;
    &lt;salary&gt;75000&lt;/salary&gt;
    &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
    &lt;street&gt;123 Main Street&lt;/street&gt;
    &lt;city&gt;Chicago&lt;/city&gt;
    &lt;state&gt;IL&lt;/state&gt;
    &lt;zip&gt;12345&lt;/zip&gt;
  &lt;/employee&gt;
  .
  .
  .
&lt;/employeeFile&gt;
</pre>

<h3><a name="XmlWrappedSegments">5.8.2. Wrapped Segments</a></h3>
<p>In some cases, an XML document may contain extraneous elements that do not map directly
to a bean object or property value.  In these cases, a <tt>segment</tt> (without a <tt>class</tt> attribute)
can be used to wrap a field or group of fields.</p> 

<p>Extending the previous example, let's suppose the <tt>Employee</tt> bean object is modified
to hold a list of addresses.</p>
<pre class="java">
package example;
import java.util.Date;

public class Employee {
    String firstName;
    String lastName;
    String title;
    int salary;
    Date hireDate;
    List&lt;Address&gt; addressList;
    
    <span class="comment">// getters and setters not shown...</span>
}</pre>

<p>And let's further suppose that each employee's list of addresses is enclosed in a new element called
<tt>addresses</tt>.</p>
<pre class="file">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;employeeFile&gt;
  &lt;employee&gt;
    &lt;firstName&gt;Joe&lt;/firstName&gt;
    &lt;lastName&gt;Smith&lt;/lastName&gt;
    &lt;title&gt;Developer&lt;/title&gt;
    &lt;salary&gt;75000&lt;/salary&gt;
    &lt;hireDate&gt;2009-10-12&lt;/hireDate&gt;
    &lt;addresses&gt;
      &lt;mailingAddress&gt;
        &lt;street&gt;123 Main Street&lt;/street&gt;
        &lt;city&gt;Chicago&lt;/city&gt;
        &lt;state&gt;IL&lt;/state&gt;
        &lt;zip&gt;12345&lt;/zip&gt;
      &lt;/mailingAddress&gt;
    &lt;/addresses&gt;
  &lt;/employee&gt;
  .
  .
  .
&lt;/employeeFile&gt;
</pre>

<p>The mapping file can now be updated as follows:</p>
<pre class="file">
&lt;beanio&gt;

  &lt;stream name="employeeFile" format="xml"&gt;
    &lt;record name="employee" class="example.Employee"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;field name="title" /&gt;
      &lt;field name="salary" /&gt;
      &lt;field name="hireDate" type="date" /&gt;
      <span class="highlight">&lt;segment name="addresses"&gt;</span>
        &lt;segment name="mailingAddress" class="example.Address" collection="list" minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;field name="street" /&gt;
          &lt;field name="city" /&gt;
          &lt;field name="state" /&gt;      
          &lt;field name="zip" /&gt;
        &lt;/segment&gt;
      <span class="highlight">&lt;/segment&gt;</span>
    &lt;/record&gt; 
  &lt;/stream&gt;
  
&lt;/beanio&gt;</pre>

<p>The following table illustrates various effects using a segment based on the <tt>xmlType</tt>
of a field, and the effect of <tt>minOccurs</tt> and <tt>nillable</tt> when marshalling null field values.</p>

<table class="indent">
<tr>
  <th>Field Mapping</th>
  <th>Non-Null Field Value</th>
  <th>Null Field Value</th>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td rowspan="5"><pre>&lt;wrapper&gt;
  &lt;field&gt;value&lt;/field&gt;
&lt;/wrapper&gt;</pre>
</td>
  <td><pre>&lt;wrapper&gt;
  &lt;field/&gt;
&lt;/wrapper&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">minOccurs="0"</span>&gt;
  &lt;field name="field" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>-</pre></td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">nillable="true"</span>&gt;
  &lt;field name="field" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>&lt;wrapper xsi:nil="true"/&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" <span class="highlight">nillable="true"</span> /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>&lt;wrapper&gt;
  &lt;field xsi:nil="true"/&gt;
&lt;/wrapper&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" <span class="highlight">minOccurs="0"</span>/&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>&lt;wrapper/&gt;</pre>
</td>
</tr>

<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" xmlType="attribute" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td rowspan="3"><pre>&lt;wrapper field="value"/&gt;</pre></td>
  <td><pre>&lt;wrapper/&gt;</pre></td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" xmlType="attribute" <span class="highlight">minOccurs="1"</span> /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>&lt;wrapper field=""/&gt;</pre></td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">minOccurs="0"</span>&gt;
  &lt;field name="field" xmlType="attribute" minOccurs="1" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>-</pre></td>
</tr>

<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" xmlType="text" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td rowspan="3"><pre>&lt;wrapper&gt;value&lt;/wrapper&gt;</pre>
</td>
  <td><pre>&lt;wrapper/&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">nillable="true"</span>&gt;
  &lt;field name="field" xmlType="text" /&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>&lt;wrapper xsi:nil="true"/&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">minOccurs="0"</span>&gt;
  &lt;field name="field" xmlType="text"/&gt;
&lt;/segment&gt;</pre>
  </td>
  <td><pre>-</pre></td>
</tr>
</table>


<p>Similarly, a <tt>segment</tt> can be used to wrap a repeating field as illustrated below.</p>
<table class="indent">
<tr>
  <th>Field Mapping</th>
  <th>Collection</th>
  <th>Null or Empty Collection</th>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" collection="list" 
    <span class="highlight">minOccurs="0"</span> maxOccurs="10" /&gt;
&lt;/segment name="wrapper"&gt;</pre>
  </td>
  <td rowspan="4"><pre>&lt;wrapper&gt;
  &lt;field&gt;value1&lt;/field&gt;
  &lt;field&gt;value2&lt;/field&gt;  
&lt;/wrapper&gt;</pre>
</td>
  <td><pre>&lt;wrapper /&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper"&gt;
  &lt;field name="field" collection="list" 
    <span class="highlight">minOccurs="1"</span> maxOccurs="10" /&gt;
&lt;/wrapper&gt;</pre>
  </td>
  <td><pre>&lt;wrapper&gt;
  &lt;field/&gt;
&lt;/wrapper&gt;</pre>
</td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">minOccurs="0"</span>&gt;
  &lt;field name="field" collection="list" 
    minOccurs="1" maxOccurs="10" /&gt;
&lt;/wrapper&gt;</pre>
  </td>
  <td><pre>-</pre></td>
</tr>
<tr>
  <td><pre>&lt;segment name="wrapper" <span class="highlight">nillable="true"</span>&gt;
  &lt;field name="field" collection="list" 
    minOccurs="1" maxOccurs="10" /&gt;
&lt;/wrapper&gt;</pre>
  </td>
  <td><pre>&lt;wrapper xsi:nil="true"/&gt;</pre>
</td>
</tr>
</table>


<!-- 

	SPRING BATCH

 -->
<h1><a name="SpringBatch">6.0. Spring Batch Integration</a></h1>
<p>As of release 1.2, BeanIO can be used to read and write flat files with 
<a href="http://static.springsource.org/spring-batch/">Spring Batch</a> (2.1.x), 
a batch processing framework by SpringSource.</p>

<h2><a name="SpringItemReaderWriter">6.1. BeanIO ItemReader/Writer Beans</a></h2>
<p>The class <tt>org.beanio.spring.BeanIOFlatFileItemReader</tt> implements Spring Batch's
<tt>ItemReader</tt> interface and can be used to read flat files using a BeanIO stream
mapping file.  The following Spring bean definition shows a BeanIO item reader configuration
that loads a BeanIO mapping file called 'mapping.xml' from the classpath to read a file
called 'in.txt'.  The location of the mapping file is set using the <tt>streamMapping</tt>
property, and the name of the stream layout is specified using the <tt>streamName</tt>
property.</p>
<pre class="file">
  &lt;bean id="itemReader" class="org.beanio.spring.BeanIOFlatFileItemReader"&gt;
    &lt;property name="streamMapping" value="classpath:/mapping.xml" /&gt;
    &lt;property name="streamName" value="stream" /&gt;
    &lt;property name="resource" value="file:in.txt" /&gt;
  &lt;/bean&gt;</pre>

<p>Similarly, the class <tt>org.beanio.spring.BeanIOFlatFileItemWriter</tt> implements Spring Batch's
<tt>ItemWriter</tt> interface and can be used to write flat files using a BeanIO stream
mapping file.  The following Spring bean definition shows a BeanIO item writer configuration
that loads a BeanIO mapping file called 'mapping.xml' from the classpath to write a file
called 'out.txt'.</p>
<pre class="file">
  &lt;bean id="itemWriter" class="org.beanio.spring.BeanIOFlatFileItemWriter"&gt;
    &lt;property name="streamMapping" value="classpath:/mapping.xml" /&gt;
    &lt;property name="streamName" value="stream" /&gt;
    &lt;property name="resource" value="file:out.txt" /&gt;
  &lt;/bean&gt;</pre>

<p>BeanIO item readers and writers are restartable, and support many of the same properties supported
by the flat file item reader and writer included with Spring Batch.  Please refer to their 
<a href="http://www.beanio.org/docs/api/index.html">API documentation</a> for details.</p>

<h2><a name="SpringStreamFactory">6.2. BeanIO StreamFactory Bean</a></h2>
<p>By default, a BeanIO item reader/writer creates its own stream factory, but
in cases where this could cause one or more mapping files to be loaded multiple times, it may be preferable 
to create a shared stream factory instance.  BeanIO's <tt>org.beanio.spring.BeanIOStreamFactory</tt> class
can be used to create a shared stream factory that can be injected into BeanIO item readers and writers.
The following Spring beans configuration file illustrates this:</p>

<pre class="file">
&lt;beans&gt;

  <span class="highlight">&lt;bean id="streamFactory" class="org.beanio.spring.BeanIOStreamFactory"&gt;
    &lt;property name="streamMappings"&gt;
      &lt;list&gt;
        &lt;value&gt;classpath:/mapping1.xml&lt;/value&gt;
        &lt;value&gt;file:/mapping2.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</span>
  
  &lt;bean id="itemReader" class="org.beanio.spring.BeanIOFlatFileItemReader"&gt;
    <span class="highlight">&lt;property name="streamFactory" ref="streamFactory" /&gt;</span>
    &lt;property name="streamName" value="stream" /&gt;
    &lt;property name="resource" value="file:in.txt" /&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre>


<h1><a name="Configuration">7.0. Configuration</a></h1>
<p>In some cases, BeanIO behavior can be controlled by setting optional property values.  Properties
can be set using System properties or a property file.  BeanIO will load configuration
setting in the following order of priority:</p>
<ol>
<li>System properties.</li>
<li>A property file named <tt>beanio.properties</tt>.  The file will be looked for first in the application's
  working directory, and then on the classpath.</li>
</ol>
<p>The name and location of <tt>beanio.properties</tt> can be overridden using the System
property <tt>org.beanio.configuration</tt>.  In the following example, configuration settings will 
be loaded from the file named <tt>config/settings.properties</tt>, first relative to the application's
working directory, and if not found, then from the root of the application's classpath.</p>
<pre class="indent">java <span class="highlight">-Dorg.beanio.configuration=config/settings.properties</span> example.Main</pre>

<h2><a name="ConfigurationSettings">7.1. Settings</a></h2>
<p>The following configuration settings are supported by BeanIO:</p>
<table class="indent">
<tr>
  <th>Property</th>
  <th>Description</th>
  <th>Default</th>
</tr>
<tr>
  <td><tt>org.beanio.propertyEscapingEnabled</tt></td>
  <td>Whether <a href="#property"><tt>property</tt></a> values (for <tt>typeHandler</tt>, <tt>reader</tt> 
    and <tt>writer</tt> elements) support escape patterns for line feeds, carriage returns, tabs, etc.  
    Set to <tt>true</tt> or <tt>false</tt>.</td>
  <td><tt>true</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.marshalDefaultEnabled</tt></td>
  <td>Whether a configured <a href="#field"><tt>field</tt></a> default is marshalled for null property values.
    May be disabled for backwards compatibility by setting the value to <tt>false</tt>.
    </td>
  <td><tt>true</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.defaultDateFormat</tt></td>
  <td>Sets the default <tt>SimpleDateFormat</tt> pattern for <tt>date</tt> type fields in
    CSV, delimited and fixed length file formats.</td>
  <td><tt>DateFormat. getDateInstance()</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.defaultDateTimeFormat</tt></td>
  <td>Sets the default <tt>SimpleDateFormat</tt> pattern for <tt>datetime</tt> type fields in
    CSV, delimited and fixed length file formats..</td>
  <td><tt>DateFormat. getDateTimeInstance()</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.defaultTimeFormat</tt></td>
  <td>Sets the default <tt>SimpleDateFormat</tt> pattern for <tt>time</tt> type fields in
    CSV, delimited and fixed length file formats..</td>
  <td><tt>DateFormat. getTimeInstance()</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.xml.defaultXmlType</tt></td>
  <td>Sets the default XML type for a field in an XML formatted stream.  May be set
    to <tt>element</tt> or <tt>attribute</tt>.</td>
  <td><tt>element</tt></td>
</tr>
<tr>
  <td><tt>org.beanio.xml.xsiNamespacePrefix</tt></td>
  <td>Sets the default prefix for the namespace <tt>http://www.w3.org/2001/XMLSchema-instance</tt>.</td>
  <td><tt>xsi</tt></td>
</tr>
</table>


<!-- 

	APPENDIX A
	
 -->
<h1><a name="A">Appendix A:  XML Mapping File Reference</a></h1>
<p>Appendix A is the complete reference for the BeanIO 2.x XML mapping file schema.  The root element
of a mapping file is <tt><a href="#beanio">beanio</a></tt> with namespace 
<tt>http://www.beanio.org/2012/03</tt>.  The following notatiion is used to indicate the
allowed number of child elements:
 </p>
<div style="margin-left: 5%">
	* Zero, one or more<br />
	+ One or more<br />
	? Zero or one<br />
</div>

<h2><a name="beanio">A.1. <tt>beanio</tt></a></h2>
<p>The <tt>beanio</tt> element is the root element for a BeanIO mapping file.</p>
<p>Children:
<a href="#import"><tt>import</tt></a>*,
<a href="#typeHandler"><tt>typeHandler</tt></a>*,
<a href="#template"><tt>template</tt></a>*,
<a href="#stream"><tt>stream</tt></a>*
</p>

<h2><a name="import">A.2. <tt>import</tt></a></h2>
<p>The <tt>import</tt> element is used to import type handlers, templates and streams
from an external mapping file.  Streams declared in a mapping file being imported are 
not affected by global type handlers or templates declared in the file that imported it.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>resource</tt></td>
  <td>The name of the resource to import.  
    <p>The resource name must be qualified with 'classpath:' to load the resource from 
    the classpath, or with 'file:' to load the file relative to the application's working 
    directory.</p></td>
  <td>Yes</td>
</tr>
</table>

<h2><a name="typeHandler">A.3. <tt>typeHandler</tt></a></h2>
<p>A <tt>typeHandler</tt> element is used to declare a custom field type handler
that implements the <a href="http://beanio.org/docs/api/org/beanio/types/TypeHandler.html">
<tt>org.beanio.types.TypeHandler</tt></a> interface.  A type handler
can be registered for a specific Java type, or registered for a Java type and stream format 
combination, or explicitly named.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The type handler name.  A <a href="#field">field</a> can always reference a type
    handler by name, even if the stream format does not match the
    configured type handler <tt>format</tt> attribute.
    <p>When configured, the name of a globally declared type handler must be unique
      within a mapping and any imported mapping files.</p></td>
  <td>One of <tt>name</tt> or <tt>type</tt> is required.</td>
</tr>
<tr>
  <td><tt>type</tt></td>
  <td>The fully qualified classname or type alias to register the type handler for.
    If <tt>format</tt> is also set, the type handler will only be used
    by streams that match the configured format.
    </td>
  <td>One of <tt>name</tt> or <tt>type</tt> is required.</td>
</tr>
<tr>
  <td><tt>class</tt></td>
  <td>The fully qualified classname of the <tt>TypeHandler</tt> implementation.</td>
  <td>Yes</td>
</tr>
<tr>
  <td><tt>format</tt></td>
  <td>When used in conjunction with the <tt>type</tt> attribute, a type handler can be
    registered for a specific stream format.  Set to <tt>xml</tt>, <tt>csv</tt>,
    <tt>delimited</tt>, or <tt>fixedlength</tt>.  If not set, the type handler may be
    used by any stream format.</td>
  <td>No</td>
</tr>
</table>

<p>Children: 
<a href="#property"><tt>property</tt></a>*
</p>

<h2><a name="property">A.4. <tt>property</tt></a></h2>
<p>A <tt>property</tt> element is used to customize other elements, such
as a <a href="#typeHandler"><tt>typeHandler</tt></a> or <a href="#parser"><tt>parser</tt></a>.</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The property name.</td>
  <td>Yes</td>
</tr>
<tr>
  <td><tt>value</tt></td>
  <td>The property value.
    <p>When used to customize a <a href="#typeHandler"><tt>typeHandler</tt></a>
      or <a href="#parser"><tt>parser</tt></a>, default type handlers only are used to convert
      property text to an object value.  String and Character type property values can use the following escape
      sequences: <tt>\\</tt> (Backslash), <tt>\n</tt> (Line Feed), <tt>\r</tt> (Carriage Return), <tt>\t</tt> (Tab),
      and <tt>\f</tt> (Form Feed).  A backslash preceding any other character is ignored.</p>
  </td>
  <td>Yes</td>
</tr>
</table>

<p>A <tt>property</tt> element, when used as child of a <a href="#record"><tt>record</tt></a> or 
<a href="#segment"><tt>segment</tt></a> element, can be used to set 
constant values on a record or bean object that do not map to a field in the input or output stream.  
The following additional attributes are accepted in this scenario:</p>
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Format(s)</th>
</tr>
<tr>
  <td><tt>getter</tt></td>
  <td>The getter method used to retrieve the property value from its parent bean class.
    By default, the getter method is determined through intropection using
    the property name.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>setter</tt></td>
  <td>The setter method used to set the property value on its parent bean class.  
    By default, the setter method is determined through intropection using
    the property name.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>rid</tt></td>
  <td>Record identifier indicator for marshalling/writing only.  Set to <tt>true</tt> if this property is 
    used to identify the record mapping configuration used to marshall a bean object.  
    More than one property or field can be used for identification.  Defaults to <tt>false</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>type</tt></td>
  <td>The fully qualified class name or type alias of the property value.  By default,
    BeanIO will derrive the property type from the bean class.  This attribute
    can be used to override the default or may be required if the bean class
    is of type <tt>Map</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>typeHandler</tt></td>
  <td>The name of the type handler to use for type conversion.  By default, BeanIO
    will select a type handler based on <tt>type</tt> when set, or through 
    introspection of the property's parent bean class.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>format</tt></td>
  <td>The decimal format pattern for <tt>Number</tt> type properties, or the simple
    date format pattern for <tt>Date</tt> type properties.
    <p>The <tt>format</tt> value can accessed by any custom type handler that
    implements <tt>ConfigurableTypeHandler</tt>.</p>  
  </td>
  <td>No</td>
  <td>*</td>
</tr>
</table>


<h2><a name="template">A.5. <tt>template</tt></a></h2>
<p>The <tt>template</tt> element is used to create reusable lists of bean properties.</p>
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of the template.  Template names must be unique within a mapping file
    and any imported mapping files.</td>
  <td>Yes</td>
</tr>
</table>
<p>Children: 
( <a href="#field"><tt>field</tt></a> | 
<a href="#property"><tt>property</tt></a> |
<a href="#segment"><tt>segment</tt></a> |
<a href="#include"><tt>include</tt></a> )*
</p>

<h2><a name="include">A.6. <tt>include</tt></a></h2>
<p>The <tt>include</tt> element is used to include a template in a <a href="#record"><tt>record</tt></a>,
<a href="#segment"><tt>segment</tt></a>, or another <a href="#template"><tt>template</tt></a>.</p>
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>template</tt></td>
  <td>The name of the template to include.</td>
  <td>Yes</td>
</tr>
<tr>
  <td><tt>offset</tt></td>
  <td>The offset added to field positions included by the template.  Defaults to 0. </td>
  <td>No</td>
</tr>
</table>


<h2><a name="stream">A.7. <tt>stream</tt></a></h2>
<p>A <tt>stream</tt> element defines the record layout of an input or output stream.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Format(s)</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of the stream.</td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>format</tt></td>
  <td>The stream format.  Either <tt>xml</tt>, <tt>csv</tt>, <tt>delimited</tt> or
    <tt>fixedlength</tt></td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>mode</tt></td>
  <td>By default, a stream mapping can be used for both reading input streams and writing 
    output streams, called <tt>readwrite</tt> mode.  Setting mode to <tt>read</tt> or 
    <tt>write</tt> instead, respectively restricts usage to a <tt>BeanReader</tt> or a 
    <tt>BeanWriter</tt> only, but relaxes some validations on the mapping configuration.
    <p>When mode is set <tt>read</tt>, a bean class does not require getter methods. </p>
    <p>When mode is set <tt>write</tt>, a bean class may be abstract or an interface, and does
      not require setter methods.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>resourceBundle</tt></td>
  <td>The name of the resource bundle for customizing error messages.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>strict</tt></td>
  <td><b>TODO - what does this do??</b>  When set to <tt>false</tt>, records may appear in any order, and specifying 
    a record <tt>order</tt> will cause a configuration error to be thrown.  
    Defaults to <tt>true</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>The minimum number of times the record layout must be read from an
    input stream.  Defaults to <tt>0</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxOccurs</tt></td>
  <td>The maximum number of times the record layout can repeat when read from an
    input stream.  Defaults to <tt>1</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>xmlType</tt></td>
  <td>The XML node type mapped to the stream.  
  If not specified or set to <tt>element</tt>, the stream is mapped to the root element of the
  XML document being marshalled or unmarshalled.  If set to <tt>none</tt>, the XML input stream 
  will be fully read and mapped to a child <a href="#group"><tt>group</tt></a> or 
  <a href="#record"><tt>record</tt></a>.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlName</tt></td>
  <td>The local name of the XML element mapped to the stream.  Defaults to the stream name.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlNamespace</tt></td>
  <td>The namespace of the XML element mapped to the stream.  Defaults to '*' which will ignore
    namespaces while marshalling and unmarshalling.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlPrefix</tt></td>
  <td>The namespace prefix assigned to the declared <tt>xmlNamespace</tt> for marshalling XML.  
    If not specified, the default namespace (i.e. <tt>xmlns="..."</tt>) is used.</td>
  <td>No</td>
  <td>xml</td>
</tr>
</table>

<p>Children: 
<a href="#parser"><tt>parser</tt></a>?,
<a href="#typeHandler"><tt>typeHandler</tt></a>*,
( <a href="#record"><tt>record</tt></a> |
<a href="#group"><tt>group</tt></a> )+
</p>

<h2><a name="parser">A.8. <tt>parser</tt></a></h2>
<p>A <tt>parser</tt> element is used to customize or replace the default record parser factory
for a stream.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
</tr>
<tr>
  <td><tt>class</tt></td>
  <td>The fully qualified class name of the <a href="../api/org/beanio/stream/RecordParserFactory.html">
    <tt>org.beanio.stream.RecordParserFactory</tt></a> implementation
    to use for this stream.  If not specified, one of the following default factories is 
    used based on the stream format:<br />
    <br />csv - <a href="../api/org/beanio/stream/csv/CsvRecordParserFactory.html"><tt>org.beanio.stream.csv.CsvRecordParserFactory</tt></a>
    <br />delimited - <a href="../api/org/beanio/stream/delimited/DelimitedRecordParserFactory.html"><tt>org.beanio.stream.delimited.DelimitedRecordParserFactory</tt></a>
    <br />fixedlength - <a href="../api/org/beanio/stream/fixedlength/FixedLengthRecordParserFactory.html"><tt>org.beanio.stream.fixedlength.FixedLengthRecordParserFactory</tt></a>
    <br />xml - <a href="../api/org/beanio/stream/xml/XmlRecordParserFactory.html"><tt>org.beanio.stream.xml.XmlRecordParserFactory</tt></a>
    <p>Overriding the record parser factory for XML is not supported (but also not prevented).</p>
  </td>
  <td>No</td>
</tr>
</table>

<p>Children: 
<a href="#property"><tt>property</tt></a>*
</p>


<h2><a name="group">A.9. <tt>group</tt></a></h2>
<p>A <tt>group</tt> element is used to group records together for validating occurrences of
the group as a whole.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Format(s)</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of the group.</td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>class</tt></td>
  <td>The fully qualified class name of the bean object mapped to this group.  A <tt>class</tt>
    may be bound to a group when its marshalled form spans multiple consecutive records.
    <p>During umarshalling, if any record in the group fails validation, an 
    <tt>InvalidRecordGroupException</tt> is thrown.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>order</tt></td>
  <td>The order this group must appear within its parent group or stream.  
    <p>If <tt>strict</tt> is set to true at the stream level, <tt>order</tt> will default
    to the order assigned to its preceding sibling plus one (i.e. the record or group that
    shares the same parent), or 1 if this group is the first child in its parent group or stream.  
    If <tt>strict</tt> is false, defaults to 1.</p>
     
    <p>If <tt>order</tt> is explicitly set for one group, it must be set for all other siblings
    that share the same parent.</p> 
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>The minimum number of occurences of this group within its parent group or stream.
    Defaults to 1.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxOccurs</tt></td>
  <td>The maximum number of occurences of this group within its parent group or stream.
    Defaults to <tt>unbounded</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>xmlType</tt></td>
  <td>The XML node type mapped to this group.  
  If not specified or set to <tt>element</tt>, this group is mapped to an XML element.  When set to 
  <tt>none</tt>, this group is used only to define expected record sequencing.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlName</tt></td>
  <td>The local name of the XML element mapped to this group.  Defaults to the group name.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlNamespace</tt></td>
  <td>The namespace of the XML element mapped to this group.  Defaults to the namespace declared for the
    parent stream or group definition.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlPrefix</tt></td>
  <td>The namespace prefix assigned to the declared <tt>xmlNamespace</tt> for marshalling XML.  
    If not specified, the default namespace is used (i.e. <tt>xmlns="..."</tt>).</td>
  <td>No</td>
  <td>xml</td>
</tr>
</table>

<p>Children: 
<a href="#record"><tt>record</tt></a>*
</p>

<h2><a name="record">A.10. <tt>record</tt></a></h2>
<p>A <tt>record</tt> is used to define a record mapping within a stream.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Format(s)</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of the record.</td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>class</tt></td>
  <td>The fully qualified class name of the bean object mapped to this record.
    <p>If set to <tt>map</tt> or 
    any <tt>java.util.Map</tt> implementation, a Map object will be used with field names
    for keys and field values for values.</p>
    <p>If neither <tt>class</tt> or <tt>target</tt> is set, a <tt>BeanReader</tt> will fully 
    validate the record, but no bean object will be returned and the reader will continue reading 
    the next record.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>target</tt></td>
  <td>The name of a segment or field descendant to return in lieu of an assigned class.
    <p>There can be only one iteration of a named target.  For example, if a repeating segment
    bound to a collection contains a repeating field (also bound to a collection), the segment 
    can be targeted, but the field cannot.</p>
    <p>If neither <tt>class</tt> or <tt>target</tt> is set, a <tt>BeanReader</tt> will fully 
    validate the record, but no bean object will be returned and the reader will continue reading 
    the next record.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>getter</tt></td>
  <td>The getter method used to get the bean object bound to this record from 
    it's parent.  By default, the getter method is determined through intropection using
    the record name.  Ignored if <tt>class</tt> is not set.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>setter</tt></td>
  <td>The setter method used to set the bean object bound to this record on the bean object of
    it's parent.  By default, the setter method is determined through intropection using
    the record name.  Ignored if <tt>class</tt> is not set.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>collection</tt></td>
  <td>The collection type for repeating records bound to a parent bean object (configured on
    a <a href="#group"><tt>group</tt></a>).  The value may be set to any fully qualified class name 
    assignable to <tt>java.util.Collection</tt>,
    or to one of the collection type aliases: <tt>list</tt>, <tt>set</tt> or <tt>array</tt>.
    A collection type can only be set if <tt>class</tt> is also set.
    <p>BeanIO will not derrive the collection type from it's parent bean object.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>order</tt></td>
  <td>The order this record must appear within its parent group or stream.  
    <p>If <tt>strict</tt> is set to true at the stream level, <tt>order</tt> will default
    to the order assigned to its preceding sibling plus one (i.e. the record or group that
    shares the same parent), or 1 if this record is the first child in its parent group or stream.  
    If <tt>strict</tt> is false, defaults to 1.</p>
     
    <p>If <tt>order</tt> is explicitly set for one record, it must be set for all other siblings
    that share the same parent.</p> 
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>The minimum number of occurences of this record within its parent group or stream.
    Defaults to 0.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxOccurs</tt></td>
  <td>The maximum number of occurrences of this record within its parent group or stream.
    Defaults to <tt>unbounded</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>template</tt></td>
  <td>The name of the template to include.  The template is added to the record layout 
    before any child of this record.
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minLength</tt></td>
  <td>If the stream format is <tt>delimited</tt> or <tt>csv</tt>, <tt>minLength</tt> is the minimum number
    of fields required by this record.  If <tt>strict</tt> is true, defaults to the number of fields defined 
    for the record, otherwise 0.
    <p>If the stream format is <tt>fixedlength</tt>, <tt>minLength</tt> is the minimum number 
    of characters required by this record.  If <tt>strict</tt> is true, defaults to the sum of all field lengths 
    definied for the record, otherwise 0.</p>
    </td>
  <td>No</td>
  <td>csv, delimited, fixedlength</td>
</tr>
<tr>
  <td><tt>maxLength</tt></td>
  <td>If the stream format is <tt>delimited</tt> or <tt>csv</tt>, <tt>maxLength</tt> is the maximum number
    of fields allowed by this record.  If <tt>strict</tt> is true, defaults to the number of fields defined 
    for the record, or if no fields are declared or <tt>strict</tt> is false, then <tt>unbounded</tt>.
    <p>If the stream format is <tt>fixedlength</tt>, <tt>maxLength</tt> is the maximum number 
    of characters allowed by this record.  If <tt>strict</tt> is true, defaults to the sum of all field lengths 
    defined for the record, or if no fields are declared or <tt>strict</tt> is false, then <tt>unbounded</tt>.</p>
    </td>
  <td>No</td>
  <td>csv, delimited, fixedlength</td>
</tr>
<tr>
  <td><tt>xmlName</tt></td>
  <td>The local name of the XML element mapped to this record.  Defaults to the record name.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlNamespace</tt></td>
  <td>The namespace of the XML element mapped to this record.  Defaults to the namespace declared for
    this record's parent group or stream.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlPrefix</tt></td>
  <td>The namespace prefix assigned to the declared <tt>xmlNamespace</tt> for marshalling XML.  
    If not specified, the default namespace is used (i.e. <tt>xmlns="..."</tt>).</td>
  <td>No</td>
  <td>xml</td>
</tr>
</table>

<p>Children: 
( <a href="#field"><tt>field</tt></a> | 
<a href="#property"><tt>property</tt></a> |
<a href="#segment"><tt>segment</tt></a> |
<a href="#include"><tt>include</tt></a> )*
</p>


<h2><a name="segment">A.11. <tt>segment</tt></a></h2>
<p>A <tt>segment</tt> is used to bind groups of fields to a nested bean object, or to validate
repeating groups of fields, or in an XML formatted stream, to wrap one or more fields in an element.</p>
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Format(s)</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of the segment.  If the segment is bound to a bean object, the segment
    name is used for the name of the bean property unless a <tt>getter</tt> or <tt>setter</tt>
    is set.</td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>class</tt></td>
  <td>The fully qualified class name of the bean object bound to this segment. 
    If set to <tt>map</tt> or any <tt>java.util.Map</tt> implementation, a Map object will 
    be used with field/segment names for keys and field/segment values for values.
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>getter</tt></td>
  <td>The getter method used to get the bean object bound to this segment from it's parent.  
    By default, the getter method is determined through intropection using
    the segment name.  Ignored if <tt>class</tt> is not set.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>setter</tt></td>
  <td>The setter method used to set the bean object bound to this segment on the bean object 
    of it's parent.  By default, the setter method is determined through intropection using
    the segment name.  Ignored if <tt>class</tt> is not set.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>collection</tt></td>
  <td>The collection type for repeating segments bound to a parent bean object.  
    The value may be set to any fully qualified class name 
    assignable to <tt>java.util.Collection</tt>,
    or to one of the collection type aliases: <tt>list</tt>, <tt>set</tt> or <tt>array</tt>.
    A collection type can only be set if <tt>class</tt> is also set.
    <p>BeanIO will not derrive the collection type from it's parent bean object.</p>
    <p>There are a few restrictions specific to repeating segments in any "flat" format (delimited, CSV or fixedlength):</p>
    <ul>
    <li>Repeating segments must appear in the stream consecutively.</li>
    <li>A repeating segment cannot contain repeating fields or segments where
      the length is indeterminate (i.e. where <tt>minOccurs</tt> does not match <tt>maxOccurs</tt>).</li>
    <li>Repeating segments must fully declare all child fields- there can be no gaps in the definition.
      (However, you can still skip over unbound values using the <tt>ignore</tt> field attribute.)</li>
    </ul>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>The minimum consecutive occurrences of this segment.  Defaults to 1.
    <p>If <tt>minOccurs</tt> is 0, a null bean object bound to this segment will
     not be marshalled (unless a subsequent field is marshalled for CSV, delimited and 
     fixed legnth stream formats)</p>
    <p>During unmarshalling, if the configured minimum occurrences is not met, 
      an <tt>InvalidRecordException</tt> is thrown.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxOccurs</tt></td>
  <td>The maximum consecutive occurrences of this segment.  By default, 
    <tt>maxOccurs</tt> is set to <tt>minOccurs</tt> or 1, whichever is greater.
    If there is no limit to the number of occurrences, the value may 
    be set to <tt>unbounded</tt>.
    
    <p>If set for a CSV, delimited or fixed length stream, the value can only 
    exceed <tt>minOccurs</tt> if the segment appears at the end of a record.  </p>
    <p>Maximum occurrences is not used for validation.  If bounded, the
      size of a bound collection will not exceed the configured value, and additional occurrences
      are ignored.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>template</tt></td>
  <td>The name of the template to include.  The template is added to the layout 
    before any child of this segment.
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>xmlType</tt></td>
  <td>The XML node type mapped to this segment.  
  If not specified or set to <tt>element</tt>, this bean is mapped to an XML element.  If set to 
  <tt>none</tt>, children of this segment are expected to be contained by this segment's parent.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlName</tt></td>
  <td>The local name of the XML element mapped to this segment.  Defaults to the segment name.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlNamespace</tt></td>
  <td>The namespace of the XML element mapped to this segmnet.  Defaults to the namespace declared for the
    parent <a href="#record"><tt>record</tt></a> or <tt>segmnet</tt>.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlPrefix</tt></td>
  <td>The namespace prefix assigned to the declared <tt>xmlNamespace</tt> for marshalling XML.  
    If not specified, the default namespace is used (i.e. <tt>xmlns="..."</tt>).</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>nillable</tt></td>
  <td>Set to <tt>true</tt> if the W3C Schema Instance attribute <tt>nil</tt> should be
    set to true when marshalling a null bean object.  Defaults to <tt>false</tt>.  During 
    unmarshalling, a nillable element will cause an <tt>InvalidRecordException</tt> if <tt>nillable</tt>
    is false..</td>
  <td>No</td>
  <td>xml</td>
</tr>
</table>

<p>Children: 
( <a href="#field"><tt>field</tt></a> |
<a href="#property"><tt>property</tt></a > |
<a href="#segment"><tt>segment</tt></a> |
<a href="#include"><tt>include</tt></a> )*
</p>


<h2><a name="field">A.12. <tt>field</tt></a></h2>
<p>A <tt>field</tt> element is used to bind a field belonging to a record or segment to a bean property.</p> 
<p>Attributes:</p>
<table>
<tr>
  <th>Attribute</th>
  <th>Description</th>
  <th>Required</th>
  <th>Formats</th>
</tr>
<tr>
  <td><tt>name</tt></td>
  <td>The name of field.  Unless a getter and/or setter is defined, the field name is used
    for the bean property name.</td>
  <td>Yes</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>getter</tt></td>
  <td>The getter method used to retrieve the property value for this field from its parent
    bean class.  By default, the getter method is determined through intropection using
    the field name.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>setter</tt></td>
  <td>The setter method used to set the property value of this field on its parent bean class.  
    By default, the setter method is determined through intropection using
    the field name.
    <p>If the field is a constructor argument, <tt>setter</tt> may be set to '#N', where
      N is the position of the argumnet in the constructor beginning at 1.</p>
    </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>rid</tt></td>
  <td>Record identifier indicator.  Set to <tt>true</tt> if this field is used to identify a record.  
    More than one field can be used to identify a record.  Defaults to <tt>false</tt>.
    <p>Record identifying fields must have <tt>regex</tt> or <tt>literal</tt> configured
    to match a record.</p>
    </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>position</tt></td>
  <td>For delimited and CSV formatted streams, <tt>position</tt> is the index of the field
    within the record, beginning at 0.  And for fixed length formatted streams, <tt>position</tt>
    is the index of the first character of the field within the record, beginning at 0.
    <p>
    If the field repeats, or the field belongs to a segment that repeats, 
    <tt>position</tt> should be set based on the first occurrence of the field in a record.
    </p>
    <p>
    A position must be specified for all fields in a record, or for none at all.  If positions
    are not specified, BeanIO will automatically calculate field positions based on the order
    in which the fields are defined in the mapping file.
    </p>
  </td>
  <td>No</td>
  <td>csv, delimited, fixedlength</td>
</tr>
<tr>
  <td><tt>trim</tt></td>
  <td>Set to <tt>true</tt> to trim the field text before validation and type
    conversion.  Defaults to <tt>false</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>required</tt></td>
  <td>Set to <tt>true</tt> if this field is required.  If a field is required and its field 
    text is empty, a <tt>BeanReader</tt> will throw an <tt>InvalidRecordException</tt> when 
    reading the record.  Defaults to <tt>false</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minLength</tt></td>
  <td>The minimum length of the field text before type conversion.  Defaults to 0.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxLength</tt></td>
  <td>The maximum length of the field text before type conversion.  Defaults to <tt>unbounded</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>regex</tt></td>
  <td>The regular expression pattern the field text must match.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>literal</tt></td>
  <td>Sets the <i>literal</i> or constant value of this field.  When reading an input stream,
    a <tt>BeanReader</tt> will throw an <tt>InvalidRecordException</tt> if the field text does not 
    exactly match the literal value.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>default</tt></td>
  <td>The default value of this field.
    <p>When unmarshalling a stream, this value is set on the bean object when the
    field text is null or the empty string.  And when marshalling, the
    default value is used when the property value is null or ignore is set to 
    <tt>true</tt> (unless disabled).</p>
    <p>A default value is converted to a Java object using the same type 
    handler configured for the field.</p></td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>type</tt></td>
  <td>The fully qualified class name or type alias of the field value.  By default,
    BeanIO will derrive the field type from its parent bean class.  This attribute
    can be used to override the default, or may be needed when its parent class
    is of type <tt>java.util.Map</tt>.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>collection</tt></td>
  <td>If a repeating field is bound to a collection object, <tt>collection</tt>
    is the fully qualified class name of the <tt>java.util.Collection</tt> implementation,
    or a collection type alias.  When a <tt>collection</tt> is configured, the <tt>type</tt> attribute 
    is used to declare the property type of an item stored in the collection.  
    May be set to <tt>array</tt> if the collection type is a Java array.
    <p>Repeating fields bound to a property value must have <tt>collection</tt> configured.
    BeanIO will not derrive the collection type from a field's parent bean class.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>minOccurs</tt></td>
  <td>The minimum consecutive occurrences of this field in a record.  Defaults to 1, with one
    exception: a field in an XML formatted stream bound to an attribute defaults to 0.
  
    <p><tt>minOccurs</tt> controls whether a field is marshalled for a null field value, and
     whether the field must be present during unmarshalling.  If <tt>minOccurs</tt> is 1 or
     greater and the field is not present during unmarshalling, an <tt>InvalidRecordException</tt> is thrown.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>maxOccurs</tt></td>
  <td>The maximum consecutive occurrences of this field in a record.  By default, 
    <tt>maxOccurs</tt> is set to <tt>minOccurs</tt> or 1, whichever is greater.  If overridden
    for a non-XML stream format, the value can only exceed <tt>minOccurs</tt> if this is the last field
    in the record.  The value may be set to <tt>unbounded</tt> if there is no limit to the 
    number of occurrences of this field.
    <p>Maximum occurrences is not used for validation. When bounded, the size of a 
    collection will not exceed the configured value, and additional occurrences are ignored.</p>
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>format</tt></td>
  <td>The decimal format pattern for <tt>java.lang.Number</tt> field values, or the simple
    date format pattern for <tt>java.util.Date</tt> field properties.
    <p>The <tt>format</tt> value can also be accessed by any custom type handler that
    implements <tt>org.beanio.types.ConfigurableTypeHandler</tt>.</p>  
  </td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>typeHandler</tt></td>
  <td>The name of the type handler to use for type conversion.  By default, BeanIO
    will select a type handler based on the field type when set, or through 
    introspection of this field's parent bean class.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>ignore</tt></td>
  <td>Set to <tt>true</tt> if this field is not a property of it's parent bean class.  
    Defaults to <tt>false</tt>.  Note that any configured validation rule on an ignored
    field is still performed.</td>
  <td>No</td>
  <td>*</td>
</tr>
<tr>
  <td><tt>length</tt></td>
  <td>The padded length of this field measured in characters.  Length is required for fixed
    length formatted streams, and can be set for fields in other stream formats (along with
    a padding character) to enable field padding.</td>
  <td>Yes<sup>1</sup></td>
  <td><tt>*</tt></td>
</tr>
<tr>
  <td><tt>padding</tt></td>
  <td>The character used to pad this field.  For fixed length formatted streams,
    <tt>padding</tt> defaults to a space.  For non-fixed length formatted streams,
    padding is disabled unless a padding character and length are specified.
    
    <p>If padding is enabled, the <tt>required</tt> field attribute has some control over the
    marshalling and unmarshalling of null values.</p>
    
    <p>When unmarshalling a field consisting of all spaces in a fixed length stream, 
    if <tt>required</tt> is false, the field
    is accepted regardless of the padding character.  If
    <tt>required</tt> is true, a required field validation error is triggered.  And when
    marshalling a null field value, if <tt>required</tt> is false, 
    the field text is formatted as spaces regardless of the configured padding character.
    </p>
    
    <p>In other stream formats that are not fixed length, null field values are 
    unmarshalled and marshalled as empty strings when <tt>required</tt> is false.
    When <tt>required</tt> is true, unmarshalling an empty string will trigger a required
    field validation error, and marshalling a null value will fill the field text with
    the padding character up to the padded length of the field.</p>
  </td>
  <td>No</td>
  <td><tt>*</tt></td>
</tr>
<tr>
  <td><tt>justify</tt></td>
  <td>The justification (i.e. alignment) of the field text within its padding.  Either
    <tt>left</tt> or <tt>right</tt>.  Defaults to <tt>left</tt>.</td>
  <td>No</td>
  <td><tt>*</tt></td>
</tr>
<tr>
  <td><tt>xmlType</tt></td>
  <td>The XML node type mapped to this field.  The type can be set to <tt>element</tt> (default)
  to map this field to an XML element, <tt>attribute</tt> to map to an XML attribute, or <tt>text</tt>
  to map the field value to the enclosed text of it's parent record or segment.
  
  <p>When set to <tt>text</tt>, <tt>xmlName</tt> and <tt>xmlNamespace</tt> have no effect.</p></td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlName</tt></td>
  <td>The local name of the XML element or attribute mapped to this field.  Defaults to the field name.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlNamespace</tt></td>
  <td>The namespace of the XML element mapped to this field.  Defaults to the namespace configured for it's
    immediate parent record or segment.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>xmlPrefix</tt></td>
  <td>The namespace prefix assigned to the configured <tt>xmlNamespace</tt> for marshalling XML.  
    If not specified, the default namespace (i.e. <tt>xmlns="..."</tt>) is used.</td>
  <td>No</td>
  <td>xml</td>
</tr>
<tr>
  <td><tt>nillable</tt></td>
  <td>Set to <tt>true</tt> if the W3C Schema Instance attribute <tt>nil</tt> should be
    set to true when the marshalled field value is null.  Defaults to <tt>false</tt>.
    Unmarshalling a non-nillalbe field where <tt>nil="true"</tt> will cause an
    <tt>InvalidRecordException</tt>.
  </td>
  <td>No</td>
  <td>xml</td>
</tr>
</table>
<p><sup>1</sup>Only required for fixed length fields.  If a literal value is supplied for 
a fixed length field, <tt>length</tt> will default to the length of the literal value.</p> 


<h1><a name="B">Appendix B: Error Message Parameters</a></h1>

<p>The following table shows the message parameters used to format an error
message for each configurable validation rule.</p>

<table style="vertical-align: top;">
<tr>
  <th>Type</th>
  <th>Rule Name</th>
  <th>Index</th>
  <th>Value</th>
</tr>
<tr>
  <td rowspan="12">Record Error</td>
  <td><tt>malformed</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td><tt>unidentified</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td rowspan="2"><tt>unexpected</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td rowspan="4"><tt>minLength</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Minimum Length</td>
</tr>
<tr>
  <td>3</td>
  <td>Maximum Length</td>
</tr>
<tr>
  <td rowspan="4"><tt>maxLength</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Minimum Length</td>
</tr>
<tr>
  <td>3</td>
  <td>Maximum Length</td>
</tr>
<tr>
  <td rowspan="52">Field Error</td>
  <td rowspan="4"><tt>required</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td rowspan="4"><tt>nillable</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td rowspan="6"><tt>minLength</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td>Minimum Length</td>
</tr>
<tr>
  <td>5</td>
  <td>Maximum Length</td>
</tr>
<tr>
  <td rowspan="6"><tt>maxLength</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td>Minimum Length</td>
</tr>
<tr>
  <td>5</td>
  <td>Maximum Length</td>
</tr>
<tr>
  <td rowspan="5"><tt>length</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td>Fixed Length Field Length</td>
</tr>
<tr>
  <td rowspan="5"><tt>regex</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td>Regular Expression Pattern</td>
</tr>
<tr>
  <td rowspan="5"><tt>type</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td><tt>TypeConversionException</tt> error message.</td>
</tr>
<tr>
  <td rowspan="5"><tt>literal</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>Field Text</td>
</tr>
<tr>
  <td>4</td>
  <td>Literal value</td>
</tr>
<tr>
  <td rowspan="6"><tt>minOccurs</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field or Bean Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>-</td>
</tr>
<tr>
  <td>4</td>
  <td>Minimum occurrences</td>
</tr>
<tr>
  <td>5</td>
  <td>Maximum occurences</td>
</tr>
<tr>
  <td rowspan="6"><tt>maxOccurs</tt></td>
  <td>0</td>
  <td>Line Number</td>
</tr>
<tr>
  <td>1</td>
  <td>Record Label/Name</td>
</tr>
<tr>
  <td>2</td>
  <td>Field or Bean Label/Name</td>
</tr>
<tr>
  <td>3</td>
  <td>-</td>
</tr>
<tr>
  <td>4</td>
  <td>Minimum occurrences</td>
</tr>
<tr>
  <td>5</td>
  <td>Maximum occurences</td>
</tr>
</table>


<h1><a name="C">Appendix C: Upgrading a 1.x Mapping File Example</a></h1>

<p>This appendix illustrates typical changes required to update an 1.x
mapping file to 2.x.</p> 

<p>Given the following 1.x mapping file:</p>

<pre class="file">
&lt;beanio xmlns="http://www.beanio.org/2011/01" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.beanio.org/2011/01 http://www.beanio.org/2011/01/mapping.xsd"&gt;

  &lt;stream name="employees" format="delimited"&gt;
    &lt;reader&gt;
      &lt;property name="delimiter" value="," /&gt;
    &lt;/reader&gt;
    &lt;writer&gt;
      &lt;property name="delimiter" value="," /&gt;
    &lt;/writer&gt;
    &lt;record name="header" class="example.Header" maxOccurs="1"&gt;
      &lt;field name="recordType" rid="true" literal="H" /&gt;
      &lt;field name="fileDate" format="yyyy-MM-dd" /&gt;
    &lt;/record&gt;
    &lt;record name="employee" class="example.Employee" minOccurs="0" minLength="6" maxLength="7"&gt;
      &lt;field name="recordType" rid="true" literal="D" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      &lt;bean name="address" class="example.Address" &gt;
        &lt;field name="city" /&gt;
        &lt;field name="state" /&gt;
        &lt;field name="zip" /&gt;
      &lt;/bean&gt;
      &lt;field name="phoneNumber" /&gt;
    &lt;/record&gt;
    &lt;record name="trailer" class="example.Trailer" maxOccurs="1"&gt;
      &lt;field name="recordType" rid="true" literal="T" /&gt;
      &lt;field name="recordCount" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;

  &lt;stream name="contacts" format="xml" ordered="false"&gt;
    &lt;record name="person" class="example.Person" minOccurs="0"&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" minOccurs="1" /&gt;
      &lt;field name="phone" collection="list" minOccurs="0" maxOccurs="5" xmlWrapper="phoneList" /&gt;
    &lt;/record&gt;
    &lt;record name="company" class="example.Person" minOccurs="0"&gt;
      &lt;field name="companyName" minOccurs="1" /&gt;
      &lt;field name="phone" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;

&lt;/beanio&gt;</pre>

<p>The following 2.x mapping file can be created:</p>
<pre class="file">
<span class="comment">&lt;!-- Namespace updated --&gt;</span>
&lt;beanio xmlns="<span class="highlight">http://www.beanio.org/2012/03</span>" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="<span class="highlight">http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd</span>"&gt;

  <span class="comment">&lt;!-- Use 'strict' to have BeanIO calculate and enforce default record lengths and ordering --&gt;</span>
  &lt;stream name="employees" format="delimited" <span class="highlight">strict="true"</span>&gt;
    <span class="comment">&lt;!-- Combine 'reader' and 'writer' elements into 'parser' --&gt;</span>
    <span class="highlight">&lt;parser&gt;</span>
      &lt;property name="delimiter" value="," /&gt;
    <span class="highlight">&lt;/parser&gt;</span>
    <span class="comment">&lt;!-- 'minOccurs' defaults to 0 if not specified --&gt;</span>
    &lt;record name="header" class="example.Header" <span class="highlight">minOccurs="1"</span> maxOccurs="1"&gt;
      &lt;field name="recordType" rid="true" literal="H" /&gt;
      &lt;field name="fileDate" format="yyyy-MM-dd" /&gt;
    &lt;/record&gt;
    <span class="comment">&lt;!-- 'minLength/maxLength' not needed, see 'phoneNumber' field below for explanation --&gt;</span>
    &lt;record name="employee" class="example.Employee" minOccurs="0" <del>minLength="6" maxLength="7"</del>&gt;
      &lt;field name="recordType" rid="true" literal="D" /&gt;
      &lt;field name="firstName" /&gt;
      &lt;field name="lastName" /&gt;
      <span class="comment">&lt;!-- Change 'bean' elements to 'segment' elements --&gt;</span>
      &lt;<span class="highlight">segment</span> name="address" class="example.Address" &gt;
        &lt;field name="city" /&gt;
        &lt;field name="state" /&gt;
        &lt;field name="zip" /&gt;
      &lt;/<span class="highlight">segment</span>&gt;
      <span class="comment">&lt;!-- Use 'minOccurs' to denote optional fields at the end of a record.  When used with
        -- 'strict', there is no need to set 'minLength' and 'maxLength' on the record, unless 
        -- you are not mapping every field --&gt;</span>
      &lt;field name="phoneNumber" <span class="highlight">minOccurs="0"</span> /&gt;
    &lt;/record&gt;
    &lt;record name="trailer" class="example.Trailer" <span class="highlight">minOccurs="1"</span> maxOccurs="1"&gt;
      &lt;field name="recordType" rid="true" literal="T" /&gt;
      &lt;field name="recordCount" /&gt;
    &lt;/record&gt;
  &lt;/stream&gt;

  <span class="comment">&lt;!-- Records are not ordered by default.  --&gt;</span>
  &lt;stream name="contacts" format="xml" <del>ordered="false"</del>&gt;
    <span class="comment">&lt;!-- minOccurs defaults to 0 --&gt;</span>
    &lt;record name="person" class="example.Person" <del>minOccurs="0"</del>&gt;
      <span class="comment">&lt;!-- Optional XML elements must set minOccurs to 0 --&gt;</span>
      &lt;field name="firstName" <span class="highlight">minOccurs="0"</span>/&gt;
      &lt;field name="lastName" minOccurs="1" /&gt;
      <span class="comment">&lt;!-- Use a 'segment' instead of an 'xmlWrapper' --&gt;</span>
      <span class="highlight">&lt;segment name="phoneList" minOccurs="0"&gt;</span>
        &lt;field name="phone" collection="list" minOccurs="0" maxOccurs="5" <del>xmlWrapper="phoneList"</del> /&gt;
      <span class="highlight">&lt;/segment&gt;</span>
    &lt;/record&gt;
    &lt;record name="company" class="example.Person" minOccurs="0"&gt;
      &lt;field name="companyName" <del>minOccurs="1"</del> /&gt;
      <span class="comment">&lt;!-- Optional XML elements must set minOccurs to 0 --&gt;</span>
      &lt;field name="phone" <span class="highlight">minOccurs="0"</span>/&gt;
    &lt;/record&gt;
  &lt;/stream&gt;

&lt;/beanio&gt;</pre>


<br />
<br />
<br />
</body>
</html>